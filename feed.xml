<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://jackzh.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jackzh.com/" rel="alternate" type="text/html" /><updated>2018-12-06T12:45:06-05:00</updated><id>https://jackzh.com/feed.xml</id><title type="html">Jun Zheng</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">CSCB36 Theory of Computation - Chapter 6 Predicate Logic</title><link href="https://jackzh.com/cscb36/2018/12/05/cscb36-chapter-6.html" rel="alternate" type="text/html" title="CSCB36 Theory of Computation - Chapter 6 Predicate Logic" /><published>2018-12-05T00:00:00-05:00</published><updated>2018-12-05T00:00:00-05:00</updated><id>https://jackzh.com/cscb36/2018/12/05/cscb36-chapter-6</id><content type="html" xml:base="https://jackzh.com/cscb36/2018/12/05/cscb36-chapter-6.html">&lt;p&gt;Notes taken for CSCB36 course at UofT, this post is for Chapter 6, Predicate Logic.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Predicate logic is a generalisation of propositional logic.&lt;/p&gt;

&lt;p&gt;A predicate is a boolean-valued function. The set $D$ of possible values for a predicate’s arguments is called its domain of discourse. The number $n$ of a predicate’s arguments is called it arity. So a n-ary predicate with domain of discourse $D$ is the function: $P: D \times D \times … \times D \to \{0,1\}$.&lt;/p&gt;

&lt;h2 id=&quot;combining-predicates&quot;&gt;Combining Predicates&lt;/h2&gt;

&lt;h3 id=&quot;using-propositional-connectives&quot;&gt;Using Propositional Connectives&lt;/h3&gt;

&lt;p&gt;We can use propositional connectives to combine predicates, for example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$S(x)$ - $x$ loves watching TV shows.&lt;/li&gt;
  &lt;li&gt;$A(x)$ - $x$ loves watching anime.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then conveniently connect them to form new predicates:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$S(x) \wedge \neg A(x)$ - $x$ loves watching TV shows but not anime.&lt;/li&gt;
  &lt;li&gt;$A(x) \to S(x)$ - If $x$ loves anime, then $x$ must also like TV shows.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;using-quantifiers&quot;&gt;Using Quantifiers&lt;/h3&gt;

&lt;p&gt;We can also use quantifiers, there are 2 main ones:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\exists x A$ - This is true if there is at least one $x$ so that $A$ holds. (existential quantifier)&lt;/li&gt;
  &lt;li&gt;$\forall x A$ - This is true if for all possible value of $x$, $A$ holds. (universal quantifier)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Take from above example, we can construct the following predicates:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\exists x (S(x) \wedge A(x))$ - There exists $x$ who likes TV shows and anime.&lt;/li&gt;
  &lt;li&gt;$\forall x (A(x) \to S(x))$ - For all $x$, if $x$ likes anime, then $x$ must also like TV shows.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syntax-of-predicate-logic&quot;&gt;Syntax of Predicate Logic&lt;/h2&gt;

&lt;h3 id=&quot;first-order-languages&quot;&gt;First-order Languages&lt;/h3&gt;

&lt;p&gt;A first-order lanauge contains:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Infinite set of variables.&lt;/li&gt;
  &lt;li&gt;Set of predicate symbols.&lt;/li&gt;
  &lt;li&gt;Set of constant symbols.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All symbols within the language, alongside with connectives, quantifiers, parentheses and comma constitute the basic vocabulary of first-order formulas.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;First-order language with equality is just the language that includes $\approx$ predicate symbol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;formulas&quot;&gt;Formulas&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;A term of $L$ is a variable or a constant symbol.&lt;/li&gt;
  &lt;li&gt;An atomic formula of $L$ is an expression of the form $A(t_1, t_2,…)$ ($A$ is a predicate symbol).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: The set of first-order formulate of $L$ is the smallest set such that:&lt;/p&gt;

&lt;p&gt;Basis: Any atomic formula is in the set.&lt;/p&gt;

&lt;p&gt;Induction Step: If $F_1$ and $F_2$ are in the set, and $x$ is a variable of $L$ then the following are also in the set:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\neg F_1$&lt;/li&gt;
  &lt;li&gt;$(F_1 \wedge F_2)$&lt;/li&gt;
  &lt;li&gt;$(F_1 \vee F_2)$&lt;/li&gt;
  &lt;li&gt;$(F_1 \to F_2)$&lt;/li&gt;
  &lt;li&gt;$(F_1 \iff F_2)$&lt;/li&gt;
  &lt;li&gt;$\forall x F_1$&lt;/li&gt;
  &lt;li&gt;$\exists x F_1$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;note-when-omitting-parentheses&quot;&gt;Note When Omitting Parentheses&lt;/h3&gt;

&lt;p&gt;When omitting parentheses for quantifiers, they only apply to the formula right after it.&lt;/p&gt;

&lt;p&gt;For example: $\exists x A \wedge B$ is the same as $(\exists A) \wedge B$.&lt;/p&gt;

&lt;h2 id=&quot;free-variables&quot;&gt;Free Variables&lt;/h2&gt;

&lt;p&gt;Free variables are all the variables that is not immidiately followed by a quantifier. Say $\exists y A(x, y)$, in this case $x$ is a free variable.&lt;/p&gt;

&lt;p&gt;The definition of a function called $free(F)$ to compute all free variables in a formula is the following.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Basis: $F$ is an atomic formula, say $A(t_1, t_2,…)$, $A$ is an n-ary connective. In this case, $free(F)$ is the set of terms $t_1, 1 \leq i \leq n$.&lt;/p&gt;

&lt;p&gt;Induction Step: $F$ is not an atomic formula. Then $F$ must be constructed from one or two formulas $F_1, F_2$ using a propositional connective or a quantifier. Assume that we have determined the set of free variables of $F_1$ and $F_2$. The set of free variables of $F$ are as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$F = \neg F_1$. Then $free(F) = free(F_1)$.&lt;/li&gt;
  &lt;li&gt;Connected using other propositonal connectives, then $free(F) = free(F_1) \cup free(F_2)$.&lt;/li&gt;
  &lt;li&gt;$F = \exists x F_1$ or $F = \forall x F_1$. Then $free(F) = free(F_1) - \{x\}$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: An occurrence of variable $x$ is free in $F$ iff it does not occur within a subformula of $F$ of the form $\forall x E$ or $\exists x E$.&lt;/p&gt;

&lt;p&gt;If a formula $F$ has no free variables, then it is called a sentence.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If we write out the tree representation, occurrence of variable $x$ is only free if the path to the root contains no $\forall x$ or $\exists x$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;predicate-logic-semantics&quot;&gt;Predicate Logic Semantics&lt;/h2&gt;

&lt;p&gt;For propositional logic, we cannot determine the truth value of a formula unless we did truth assignment. However it is more complicated for predicate logic (first-order formulas).&lt;/p&gt;

&lt;p&gt;Note that if we are just given a first-order formula, it doesn’t really have a meaning. For example $\exists y (A(x,y) \wedge B(c, y) \wedge C(y))$ where $c$ is a constant.&lt;/p&gt;

&lt;p&gt;We must know the domain, meaning of each predicate and the contant to parse the meaning of this formula.&lt;/p&gt;

&lt;h3 id=&quot;structures-valuations-and-interpretations&quot;&gt;Structures, Valuations and Interpretations&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Let $L$ be a first-order language. A structure $S$ for $L$ contains:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A nonempty set $D$, called the domain of $S$.&lt;/li&gt;
  &lt;li&gt;For each n-ary predicate symbol $A$ of $L$, an n-ary relation $A^S \subseteq D \times … \times D$.&lt;/li&gt;
  &lt;li&gt;For each constant symbol $c$ of $L$, an element $c^S \in D$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: Given a structure $S$ for $L$, a valuation of $S$ is a function that maps each variable of $L$ to some element of the structure’s domain $D$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: An interpretation $I$ of $L$ is a pair $(S, e)$, where $S$ is the structure and $e$ is the valuation.&lt;/p&gt;</content><author><name></name></author><category term="cscb36" /><category term="cscb36" /><category term="course-notes" /><summary type="html">Notes taken for CSCB36 course at UofT, this post is for Chapter 6, Predicate Logic.</summary></entry><entry><title type="html">CSCB36 Theory of Computation - Chapter 5 Propositional Logic</title><link href="https://jackzh.com/cscb36/2018/12/04/cscb36-chapter-5.html" rel="alternate" type="text/html" title="CSCB36 Theory of Computation - Chapter 5 Propositional Logic" /><published>2018-12-04T00:00:00-05:00</published><updated>2018-12-04T00:00:00-05:00</updated><id>https://jackzh.com/cscb36/2018/12/04/cscb36-chapter-5</id><content type="html" xml:base="https://jackzh.com/cscb36/2018/12/04/cscb36-chapter-5.html">&lt;p&gt;Notes taken for CSCB36 course at UofT, this post is for Chapter 5, Propositional Logic.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;propositional-formulas&quot;&gt;Propositional Formulas&lt;/h2&gt;

&lt;p&gt;Let $PV$ be a set of propositional variables. The set of propositional formulas, denoted $F_{PV}$ is the smallest set such that:&lt;/p&gt;

&lt;p&gt;Basis: Any propositional variable in $PV$ belongs to $F_{PV}$.&lt;/p&gt;

&lt;p&gt;Induction Step: If $P_1$ and $P_2$ belong to $F_{PV}$ then so do the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$\neg P_1$&lt;/li&gt;
  &lt;li&gt;$P_1 \wedge P_2$&lt;/li&gt;
  &lt;li&gt;$P_1 \vee P_2$&lt;/li&gt;
  &lt;li&gt;$P_1 \to P_2$&lt;/li&gt;
  &lt;li&gt;$P_1 \iff P_2$&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note: $\neg$ is called unary connective, since it is applied to one subformula, others are called binary connectives.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tree-representation-of-f_pv&quot;&gt;Tree Representation of $F_{PV}$&lt;/h3&gt;

&lt;p&gt;Propositional formulas can be nicely drawn using trees.&lt;/p&gt;

&lt;p&gt;For example, the formula $(a \vee b) \wedge \neg c$ can be drawn as&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq2DY6PnR7hE5YEXbjpYhMppeUPxTWE4VvQB/image.png&quot; alt=&quot;Tree&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;truth-assignment&quot;&gt;Truth Assignment&lt;/h2&gt;

&lt;p&gt;Let $PV$ be a set of propositional variables. A truth assignment is a function $r: PV \to \{0, 1\}$.&lt;/p&gt;

&lt;p&gt;A truth assignment tells us, for each propositional variable, whether it represents a proposition that is true or false.&lt;/p&gt;

&lt;h2 id=&quot;extended-truth-assignment&quot;&gt;Extended Truth Assignment&lt;/h2&gt;

&lt;p&gt;Extended truth assignment can be used to assign a truth value to any propositional formula, given that you have $r$.&lt;/p&gt;

&lt;p&gt;Let $r: PV \to \{0,1\}$. Define a function $r^*:F_{PV} \to \{0,1\}$ so it is the smallest set such that:&lt;/p&gt;

&lt;p&gt;Basis: $P \in PV$. In this case, $r^*(P) = r(P)$.&lt;/p&gt;

&lt;p&gt;Induction step: $P \notin PV$. Then there are $Q_1, Q_2 \in F_{PV}$ such that $P$ is one of the following formula: $\neg Q_1$, $(Q_1 \wedge Q_2)$, $(Q_1 \vee Q_2)$, $(Q_1 \to Q_2)$, and $(Q_1 \iff Q_2)$.&lt;/p&gt;

&lt;p&gt;By induction, we can assume $r^*(Q_1)$ and $r^*(Q_2)$ are already known.&lt;/p&gt;

&lt;p&gt;The function for all 5 cases are ignored since they should be trivial to figure out.&lt;/p&gt;

&lt;p&gt;If $r^*(P) = 0$ then we say $r$ falsifies $P$, otherwise it satisfies $P$.&lt;/p&gt;

&lt;h2 id=&quot;some-notes-on-logical-connectives&quot;&gt;Some Notes on Logical Connectives&lt;/h2&gt;

&lt;h3 id=&quot;inclusive--exclusive-or&quot;&gt;Inclusive / Exclusive OR&lt;/h3&gt;

&lt;p&gt;When OR is inclusive, that means if $A$ and $B$ are both true, then the whole statement is still true.&lt;/p&gt;

&lt;p&gt;When it is exclusive, it means if $A$ and $B$ are both true, then the statement is false.&lt;/p&gt;

&lt;p&gt;In formal math, we always use inclusive or, we have a special connective for exclusive or, namely xor.&lt;/p&gt;

&lt;h2 id=&quot;unique-readability-theorem&quot;&gt;Unique Readability Theorem&lt;/h2&gt;

&lt;p&gt;For any propositional formulas $P_1, P_2, Q_1, Q_2$ and binary connectives $+$ and $-$. If $(P_1 + P_2) = (Q_1 - Q_2)$ then $P_1 = Q_1$, $+ = -$ and $P_2 = Q_2$.&lt;/p&gt;

&lt;p&gt;This theroem basically states, there is only one way to construct a formula. However, if we omit the parentheses this is not going to be true anymore.&lt;/p&gt;

&lt;p&gt;Even use of parentheses is nice, but usually they are not necessary, so we use some conventions.&lt;/p&gt;

&lt;h3 id=&quot;conventions-to-omit-parentheses&quot;&gt;Conventions to Omit Parentheses&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There is no need to write outmost parentheses, say $(a \wedge b)$ is the same as $a \wedge b$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\wedge$ and $\vee$ have precedence over $\to$ and $\iff$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\wedge$ has precedence over $\vee$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Grouping is assumed to be to the right, $a \to b \to c$ is the same as $a \to (b \to c)$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;truth-tables&quot;&gt;Truth Tables&lt;/h2&gt;

&lt;p&gt;A truth table of $P$ tells us the truth value of $P$ under all possible truth assignments.&lt;/p&gt;

&lt;p&gt;For example, $x \vee y \to \neg x \wedge z$, the truth table is going to be:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0DNUDHAlpOW5DOxvSrddvXRNa2T8VFCLgB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tautologies-and-satisfiability&quot;&gt;Tautologies and Satisfiability&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;$P$ is a tautology iff every truth assignment satisfies $P$.&lt;/li&gt;
  &lt;li&gt;$P$ is satisfiable iff there is a truth assignment that satisfied $P$.&lt;/li&gt;
  &lt;li&gt;$P$ is unsatisfiable iff it is not satisfiable. In another word, $\neg P$ is a tautology.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logical-implication&quot;&gt;Logical Implication&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: A propositional formula $P$ logically implies propositional formula $Q$ if and only if every truth assignment that satisfies $P$ also satisfies $Q$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $P$ logically implies $Q$ iff $P \to Q$ is a tautology.&lt;/p&gt;

&lt;h2 id=&quot;logical-equivalence&quot;&gt;Logical Equivalence&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: $P$ is logically equivalent to $Q$ iff $P$ logically implis $Q$ and $Q$ logically implies $P$.&lt;/p&gt;

&lt;p&gt;Properties of logical equivalence:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reflexivity: $P$ is logically equivalent to $P$.&lt;/li&gt;
  &lt;li&gt;Symmetry: If $P$ is logically equivalent to $Q$ and $Q$ is logically equivalent to $P$.&lt;/li&gt;
  &lt;li&gt;Transitivity: If $P$ is logically equivalent to $Q$, and $Q$ is logically equivalent to $R$, then $P$ is logically equivalent to $R$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $P$ is logically equivalent to $Q$ iff $P \iff Q$ is a tautology.&lt;/p&gt;

&lt;h2 id=&quot;important-equivalence-laws&quot;&gt;Important Equivalence Laws&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;$\neg \neg P \equiv P$&lt;/li&gt;
  &lt;li&gt;$\neg (P \wedge Q) \equiv \neg P \vee \neg Q$&lt;/li&gt;
  &lt;li&gt;$\neg (P \vee Q) \equiv \neg P \wedge \neg Q$&lt;/li&gt;
  &lt;li&gt;$P \wedge Q \equiv Q \wedge P$&lt;/li&gt;
  &lt;li&gt;$P \vee Q \equiv Q \vee P$&lt;/li&gt;
  &lt;li&gt;$P \wedge (Q \wedge R) \equiv (P \wedge Q) \wedge R$&lt;/li&gt;
  &lt;li&gt;$P \vee (Q \vee R) \equiv (P \vee Q) \vee R$&lt;/li&gt;
  &lt;li&gt;$P \wedge (Q \vee R) \equiv (P \wedge Q) \vee (P \wedge R)$&lt;/li&gt;
  &lt;li&gt;$P \vee (Q \wedge R) \equiv (P \vee Q) \wedge (P \vee R)$&lt;/li&gt;
  &lt;li&gt;$P \wedge (Q \vee \neg Q) \equiv P$&lt;/li&gt;
  &lt;li&gt;$P \vee (Q \wedge \neg Q) \equiv P$&lt;/li&gt;
  &lt;li&gt;$P \wedge P \equiv P$&lt;/li&gt;
  &lt;li&gt;$P \vee P \equiv P$&lt;/li&gt;
  &lt;li&gt;$P \to Q \equiv \neg P \vee Q$&lt;/li&gt;
  &lt;li&gt;$P \to Q \equiv \neg Q \to \neg P$&lt;/li&gt;
  &lt;li&gt;$P \iff Q \equiv P \wedge Q \vee \neg P \wedge \neg Q$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: Let $R$ be any propositional formula, $S$ be any subformula of $R$, $S’$ be any formula that is logically equivalent to $S$, and $R’$ be the formula that results from $R$ by replacing $S$ with $S’$. Then $R’$ is logically equivalent to $R$.&lt;/p&gt;

&lt;h2 id=&quot;normal-forms-of-propositional-formulas&quot;&gt;Normal Forms of Propositional Formulas&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Literal - Only have one propositional variable or the negation of that variable.&lt;/li&gt;
  &lt;li&gt;Minterm - Is a literal, or a conjuction of two or more literals.&lt;/li&gt;
  &lt;li&gt;Maxterm - Is a literal, or a disjunction of two or more literals.&lt;/li&gt;
  &lt;li&gt;Disjunctive Normal Form - Is minterm, or a disjunction of two or more minterms.&lt;/li&gt;
  &lt;li&gt;Conjunctive Normal Form - Is maxterm, or a conjunction of two or more maxterms.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;They talked about circuit design, already took B58 which covers way more details, not going to take notes here.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;complete-sets-of-connectives&quot;&gt;Complete Sets of Connectives&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Definition&lt;/strong&gt;: A set of connectives is complete iff every boolean function can be represented by a propositional formula that uses only connectives from that set.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $\{\neg, \wedge, \vee\}$ is a complete set of connectives.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $\{\neg, \wedge\}$ is a complete set of connectives.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $\{\neg, \vee\}$ is a complete set of connectives.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $\{|\}$ is a complete set of connectives (NAND).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;: $\{\downarrow\}$ is a complete set of connectives (NOR).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$\oplus$ is exclusive or.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="cscb36" /><category term="cscb36" /><category term="course-notes" /><summary type="html">Notes taken for CSCB36 course at UofT, this post is for Chapter 5, Propositional Logic.</summary></entry><entry><title type="html">CSCB36 Theory of Computation - Chapter 0</title><link href="https://jackzh.com/cscb36/2018/12/03/cscb36-chapter-0.html" rel="alternate" type="text/html" title="CSCB36 Theory of Computation - Chapter 0" /><published>2018-12-03T00:00:00-05:00</published><updated>2018-12-03T00:00:00-05:00</updated><id>https://jackzh.com/cscb36/2018/12/03/cscb36-chapter-0</id><content type="html" xml:base="https://jackzh.com/cscb36/2018/12/03/cscb36-chapter-0.html">&lt;p&gt;Notes taken for CSCB36 course at UofT, this post is for Chapter 0, mainly talks about sets and fundamental mathematical units.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;sets&quot;&gt;Sets&lt;/h2&gt;

&lt;p&gt;If an object is $a$ in $A$, then we write $a \in A$, if not, we write $a \notin A$.&lt;/p&gt;

&lt;p&gt;If a set has 0 elements, we call that an &lt;em&gt;empty set&lt;/em&gt;, or $\emptyset$.&lt;/p&gt;

&lt;p&gt;Number of elements within a set $A$ is called its size or cardinality, denoted by $|A|$.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For infinite set $A$, $|A| = \infty$&lt;/li&gt;
  &lt;li&gt;For empty set $\emptyset$, $|\emptyset| = 0$&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;describing-sets&quot;&gt;Describing Sets&lt;/h3&gt;

&lt;p&gt;There are 2 ways to describe sets.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Extensional: List all elements within a set. For example $\{1,2,3\}$.&lt;/li&gt;
  &lt;li&gt;Intensional: Describle the set with format $\{x: \text{x is odd number}\}$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;relationship-between-sets&quot;&gt;Relationship Between Sets&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;$A \subseteq B$: If every element in $A$ is also in $B$, then $A$ is a subset of $B$.&lt;/li&gt;
  &lt;li&gt;$B \supseteq A$: If $A \subseteq B$ then this holds.&lt;/li&gt;
  &lt;li&gt;$A \subseteq B$ and $B \subseteq A$ then $A = B$.&lt;/li&gt;
  &lt;li&gt;$A \subseteq B$ and $A \neq B$ then $A$ is a proper subset of $B$, or $A \subset B$.&lt;/li&gt;
  &lt;li&gt;$B \supset A$ if $A \subset B$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Interesting properties:&lt;/p&gt;

&lt;p&gt;$\emptyset \subseteq A$ for all set $A$.&lt;/p&gt;

&lt;p&gt;$\emptyset \subset A$ for all set $A \neq \emptyset$.&lt;/p&gt;

&lt;h3 id=&quot;set-operations&quot;&gt;Set Operations&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Union of $A$ and $B$ or $A \cup B$, is the set of elements that belongs to $A$ or $B$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Intersection of $A$ and $B$ or $A \cap B$, is the set of element that belongs to $A$ and $B$. If $A \cap B = \emptyset$, then $A$ and $B$ are disjoint.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Difference of $A$ and $B$ or $A - B$, is the set of elements that belong to $A$ but not to $B$.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arbitrary-number-of-operations&quot;&gt;Arbitrary Number of Operations&lt;/h4&gt;</content><author><name></name></author><category term="cscb36" /><category term="cscb36" /><category term="course-notes" /><summary type="html">Notes taken for CSCB36 course at UofT, this post is for Chapter 0, mainly talks about sets and fundamental mathematical units.</summary></entry></feed>