<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://jackzh.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://jackzh.com/" rel="alternate" type="text/html" /><updated>2020-11-03T15:45:10-06:00</updated><id>https://jackzh.com/feed.xml</id><title type="html">Jun Zheng</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">CSCC11 Machine Learning and Data Mining</title><link href="https://jackzh.com/cscc11/2020/10/25/cscc11-classification.html" rel="alternate" type="text/html" title="CSCC11 Machine Learning and Data Mining" /><published>2020-10-25T16:17:00-05:00</published><updated>2020-10-25T16:17:00-05:00</updated><id>https://jackzh.com/cscc11/2020/10/25/cscc11-classification</id><content type="html" xml:base="https://jackzh.com/cscc11/2020/10/25/cscc11-classification.html">&lt;h2 id=&quot;classification&quot;&gt;Classification&lt;/h2&gt;

&lt;p&gt;$y = f(\vec{x})$&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Binary classification problems - $y$ is binary, for example y in [0,1] or y in [-1,1].
    &lt;ul&gt;
      &lt;li&gt;Examples
        &lt;ul&gt;
          &lt;li&gt;Spam detection (is this email a spam or not spam).&lt;/li&gt;
          &lt;li&gt;Face detection (given a small image, does it contain a face).&lt;/li&gt;
          &lt;li&gt;Diagnosis (input a list of symptoms, output be do they have COVID-19 or not).&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multiclass classification problems
    &lt;ul&gt;
      &lt;li&gt;Examples
        &lt;ul&gt;
          &lt;li&gt;Recognition problems (given image, identify which object is it)&lt;/li&gt;
          &lt;li&gt;Voice recognition (given acoustic signal, determine who is speaking)&lt;/li&gt;
          &lt;li&gt;OCR&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our focus is going to be binary classification, then generalize to multiclass classification.&lt;/p&gt;

&lt;h3 id=&quot;decision-boundary&quot;&gt;Decision Boundary&lt;/h3&gt;

&lt;p&gt;For example given the following test points, we want to determine if a fruit is grape or apple.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0o19F06W5GW5lybJ0QQrZrtnu-MXrFITUB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The red line here is the decision boundary, it is the line machine learning algorithm created, will be used to classify future inputs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Boundary in the feature space that we learn to predict the class.&lt;/li&gt;
  &lt;li&gt;Linearly separable (the example above is linear separable)
    &lt;ul&gt;
      &lt;li&gt;Data can be separated by hyperplane.&lt;/li&gt;
      &lt;li&gt;For example the graph below is not linearly separable.
&lt;img src=&quot;https://www.evernote.com/l/Aq3bjfSTatZNEYqUdKNaW3kHyGtgbnCuc70B/image.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;classification-by-regression&quot;&gt;Classification by Regression&lt;/h3&gt;

&lt;p&gt;Data: $\{\vec{x}_i, y_i\}_{i=1}^N, \vec{x}_i \in R^d, y_i \in \{-1, 1\}$&lt;/p&gt;

&lt;p&gt;Squared Loss: $\vec{w}^* arg_{\vec{w}} min \sum_{i=1}^N (y_i - \vec{w}^T\vec{x}_i)^2$&lt;/p&gt;

&lt;p&gt;Classifier: $sgn(\vec{w}^T\vec{x})$&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;$sgn(z)$ = -1 if z $\leq$ -1, 1 if z &amp;gt; 0&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq2whVnaZOxL1LIvNFML0f_fVQPONVaFvnAB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Signed distance from line $\vec{w}^T\vec{x} = 0$ is simply $\vec{x}^T\frac{\vec{w}}{||\vec{w}||}$ (x projected to the unit vector). So basically we will get positive on one side, and negative on another side.&lt;/p&gt;

&lt;p&gt;Problem with linear regression is it spends too much effort trying to get $\vec{w}^T\vec{x}$ to be close to -1 or 1. But all we care about is the sign of $\vec{w}^T\vec{x}$.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;It is solving the wrong problem!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For classifiers of form $sgn(f(x))$, a natural loss is in terms of $y \cdot f(x)$.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If $y \cdot f(x)$ is greater than 0, then we predicted correctly.&lt;/li&gt;
  &lt;li&gt;Otherwise we predicted wrongly since y and f(x) must have different signs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The issue is with the marked part of the error function, it will have penalty even for correct predictions.
&lt;img src=&quot;https://www.evernote.com/l/Aq3xn4WxjipIqqCRyzT31E9m7TR4HAbI02UB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Why not use 0-1 loss for binary classification problem?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Can’t use gradient based optimization since the function is not smooth (gradient for all errors are zero and in origin the gradient is non-existent).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;k-nn-classification&quot;&gt;K-NN Classification&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Find $k$ training points closest to test input, and use their outputs to determine our prediction.&lt;/li&gt;
  &lt;li&gt;Data $\{(\vec{x}_i, y_i)\}_{i=1}^N, y_i \in \{-1, 1\}$&lt;/li&gt;
  &lt;li&gt;Test points $\vec{x}^*$&lt;/li&gt;
  &lt;li&gt;$N_k(\vec{x}^*)$: set of k training points where input are closest to $\vec{x^*}$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The prediction is $sgn(\sum_{i\in N_k(x^*)} y_i)$ - voting of k nearest points.&lt;/p&gt;

&lt;p&gt;$sgn(\sum_{i\in N_k(x^*)} w(\vec{x}_i)y_i)$&lt;/p&gt;

&lt;p&gt;$w(\vec{x}_i) = e^{-||\vec{x}_i-\vec{x}^*||^{\frac{2}{2\sigma^2}}}$&lt;/p&gt;

&lt;p&gt;The question is how do we determine the hyper parameters k and $\sigma^2$.&lt;/p&gt;

&lt;p&gt;For this type of classification, we are basically saying if a test point is closer to a test points of one class than another, then we will predit the test point as that class.&lt;/p&gt;

&lt;p&gt;Decision boundary is piecewise lienar and very expressive.&lt;/p&gt;

&lt;p&gt;When $k&amp;gt;1$ the decision boundary is blurred as we allow more nearest neighbours to vote instead of trusting one.&lt;/p&gt;

&lt;h3 id=&quot;decision-tree&quot;&gt;Decision Tree&lt;/h3&gt;

&lt;p&gt;Tree structured sequence of decision rules.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq31-q9oHn5EnahZNu79zIal3q4SN-3brrkB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For the most part we will use binary decision trees.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$m$ internal (split) nodes.&lt;/li&gt;
  &lt;li&gt;$m+1$ leaf (terminal) nodes.&lt;/li&gt;
  &lt;li&gt;At each split node $j$ define a split function $t_j(\vec{x}): R^d \to \{-1, 1\}$
    &lt;ul&gt;
      &lt;li&gt;If -1 we go left, if 1 we go right.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each leaf node has categorical distribution over class label.
    &lt;ul&gt;
      &lt;li&gt;$P(y = c | node \ j)$
        &lt;ul&gt;
          &lt;li&gt;Let $N_j$ be the number of traning points that reach node $j$&lt;/li&gt;
          &lt;li&gt;$N_{j,c}$ number of points at node $j$ with class label c.&lt;/li&gt;
          &lt;li&gt;Then the probability is just $\frac{N_{j,c}}{N_j}$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;learning-decision-trees&quot;&gt;Learning Decision Trees&lt;/h4&gt;

&lt;p&gt;Assume at node $j$ with $N_j$ data points that reaches $j$.&lt;/p&gt;

&lt;p&gt;Consider split functions $t_j(\vec{x})$ based on a single feature.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$t_j(\vec{x}) = \vec{e}_l^T \vec{x} &amp;gt; \tau_j = x_l &amp;gt; \tau_j$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Assume $l$ is fixed (we know which feature to use).&lt;/p&gt;

&lt;p&gt;If we have $N_j$ data points, then $N_j-1$ possible thresholds.&lt;/p&gt;

&lt;p&gt;Then how do we choose the best threshold?&lt;/p&gt;

&lt;p&gt;Goal: Partition data so all points to the left and to the right have minimal class uncertainty.&lt;/p&gt;

&lt;p&gt;Entropy: Measure of uncertainty of distribution.&lt;/p&gt;

&lt;p&gt;Given categorical distribution over $k$ outcomes with probability $P_c, c \in {1…k}$, then the entropy is $-\sum_{c=1}^K P_c log_2 P_c$&lt;/p&gt;

&lt;p&gt;So our goal is to choose the threshold to minimize uncertainty in children. This is sometimes called information gain.&lt;/p&gt;

&lt;p&gt;Information gain is the reduction of the uncertainty as a result of a split.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Assume for $D$ we have $N_j$ points at node $j$.&lt;/li&gt;
  &lt;li&gt;$D_L$ have $N_L$ points.&lt;/li&gt;
  &lt;li&gt;$D_R$ have $N_R$ points.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$IG(D, split) = H(D) - \frac{N_L}{N_j} H(D_L) - \frac{N_R}{N_j} H(D_R)$&lt;/p&gt;

&lt;p&gt;The algorithm&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;At node for each $l$, for each threashold $\tau$ compute the information gain $IG(D_j, l, \tau)$$&lt;/li&gt;
  &lt;li&gt;Selection of split with $l, \tau$ that maximizes the information gain.&lt;/li&gt;
  &lt;li&gt;Stop when $H(D_j) = 0$.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;random-decision-forests&quot;&gt;Random Decision Forests&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Build many trees with random subset of features.
    &lt;ul&gt;
      &lt;li&gt;Or randomly choose features at internal nodes.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each tree gives a different distribution over class labels for an test input.
    &lt;ul&gt;
      &lt;li&gt;$P(y=c|\vec{x}^*, treeId)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Use baggnig to combine the trees
    &lt;ul&gt;
      &lt;li&gt;Take the average of distributions over all trees.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="cscc11" /><category term="cscc11" /><category term="course-notes" /><summary type="html">Classification $y = f(\vec{x})$ Binary classification problems - $y$ is binary, for example y in [0,1] or y in [-1,1]. Examples Spam detection (is this email a spam or not spam). Face detection (given a small image, does it contain a face). Diagnosis (input a list of symptoms, output be do they have COVID-19 or not). Multiclass classification problems Examples Recognition problems (given image, identify which object is it) Voice recognition (given acoustic signal, determine who is speaking) OCR Our focus is going to be binary classification, then generalize to multiclass classification. Decision Boundary For example given the following test points, we want to determine if a fruit is grape or apple. The red line here is the decision boundary, it is the line machine learning algorithm created, will be used to classify future inputs. Boundary in the feature space that we learn to predict the class. Linearly separable (the example above is linear separable) Data can be separated by hyperplane. For example the graph below is not linearly separable. Classification by Regression Data: $\{\vec{x}_i, y_i\}_{i=1}^N, \vec{x}_i \in R^d, y_i \in \{-1, 1\}$ Squared Loss: $\vec{w}^* arg_{\vec{w}} min \sum_{i=1}^N (y_i - \vec{w}^T\vec{x}_i)^2$ Classifier: $sgn(\vec{w}^T\vec{x})$ $sgn(z)$ = -1 if z $\leq$ -1, 1 if z &amp;gt; 0 Signed distance from line $\vec{w}^T\vec{x} = 0$ is simply $\vec{x}^T\frac{\vec{w}}{||\vec{w}||}$ (x projected to the unit vector). So basically we will get positive on one side, and negative on another side. Problem with linear regression is it spends too much effort trying to get $\vec{w}^T\vec{x}$ to be close to -1 or 1. But all we care about is the sign of $\vec{w}^T\vec{x}$. It is solving the wrong problem! For classifiers of form $sgn(f(x))$, a natural loss is in terms of $y \cdot f(x)$. If $y \cdot f(x)$ is greater than 0, then we predicted correctly. Otherwise we predicted wrongly since y and f(x) must have different signs. The issue is with the marked part of the error function, it will have penalty even for correct predictions. Why not use 0-1 loss for binary classification problem? Can’t use gradient based optimization since the function is not smooth (gradient for all errors are zero and in origin the gradient is non-existent). K-NN Classification Find $k$ training points closest to test input, and use their outputs to determine our prediction. Data $\{(\vec{x}_i, y_i)\}_{i=1}^N, y_i \in \{-1, 1\}$ Test points $\vec{x}^*$ $N_k(\vec{x}^*)$: set of k training points where input are closest to $\vec{x^*}$ The prediction is $sgn(\sum_{i\in N_k(x^*)} y_i)$ - voting of k nearest points. $sgn(\sum_{i\in N_k(x^*)} w(\vec{x}_i)y_i)$ $w(\vec{x}_i) = e^{-||\vec{x}_i-\vec{x}^*||^{\frac{2}{2\sigma^2}}}$ The question is how do we determine the hyper parameters k and $\sigma^2$. For this type of classification, we are basically saying if a test point is closer to a test points of one class than another, then we will predit the test point as that class. Decision boundary is piecewise lienar and very expressive. When $k&amp;gt;1$ the decision boundary is blurred as we allow more nearest neighbours to vote instead of trusting one. Decision Tree Tree structured sequence of decision rules. For the most part we will use binary decision trees. $m$ internal (split) nodes. $m+1$ leaf (terminal) nodes. At each split node $j$ define a split function $t_j(\vec{x}): R^d \to \{-1, 1\}$ If -1 we go left, if 1 we go right. Each leaf node has categorical distribution over class label. $P(y = c | node \ j)$ Let $N_j$ be the number of traning points that reach node $j$ $N_{j,c}$ number of points at node $j$ with class label c. Then the probability is just $\frac{N_{j,c}}{N_j}$ Learning Decision Trees Assume at node $j$ with $N_j$ data points that reaches $j$. Consider split functions $t_j(\vec{x})$ based on a single feature. $t_j(\vec{x}) = \vec{e}_l^T \vec{x} &amp;gt; \tau_j = x_l &amp;gt; \tau_j$ Assume $l$ is fixed (we know which feature to use). If we have $N_j$ data points, then $N_j-1$ possible thresholds. Then how do we choose the best threshold? Goal: Partition data so all points to the left and to the right have minimal class uncertainty. Entropy: Measure of uncertainty of distribution. Given categorical distribution over $k$ outcomes with probability $P_c, c \in {1…k}$, then the entropy is $-\sum_{c=1}^K P_c log_2 P_c$ So our goal is to choose the threshold to minimize uncertainty in children. This is sometimes called information gain. Information gain is the reduction of the uncertainty as a result of a split. Assume for $D$ we have $N_j$ points at node $j$. $D_L$ have $N_L$ points. $D_R$ have $N_R$ points. $IG(D, split) = H(D) - \frac{N_L}{N_j} H(D_L) - \frac{N_R}{N_j} H(D_R)$ The algorithm At node for each $l$, for each threashold $\tau$ compute the information gain $IG(D_j, l, \tau)$$ Selection of split with $l, \tau$ that maximizes the information gain. Stop when $H(D_j) = 0$. Random Decision Forests Build many trees with random subset of features. Or randomly choose features at internal nodes. Each tree gives a different distribution over class labels for an test input. $P(y=c|\vec{x}^*, treeId)$ Use baggnig to combine the trees Take the average of distributions over all trees.</summary></entry><entry><title type="html">CSC384 Artificial Intelligence - Search</title><link href="https://jackzh.com/csc384/2020/09/20/csc384-ai-search.html" rel="alternate" type="text/html" title="CSC384 Artificial Intelligence - Search" /><published>2020-09-20T16:17:00-05:00</published><updated>2020-09-20T16:17:00-05:00</updated><id>https://jackzh.com/csc384/2020/09/20/csc384-ai-search</id><content type="html" xml:base="https://jackzh.com/csc384/2020/09/20/csc384-ai-search.html">&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;Search lecture 1&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;hypothetical-reasoning&quot;&gt;Hypothetical Reasoning&lt;/h2&gt;

&lt;p&gt;What state will I be in after taking certain actions, or after certain sequences of events?&lt;/p&gt;

&lt;p&gt;From this we can reason about particular sequences of actions one should execute to achieve a desirable state.&lt;/p&gt;

&lt;p&gt;Search is a computational method for capturing a particular version of ths kind of reasoning.&lt;/p&gt;

&lt;h2 id=&quot;modeling-a-problem-as-a-search-problem&quot;&gt;Modeling a problem as a search problem&lt;/h2&gt;

&lt;p&gt;We need&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;State space
    &lt;ul&gt;
      &lt;li&gt;A state is a representation of a configuration of the problem domain. The state space is a set of states included in our model of the problem.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Actions or state space transitions
    &lt;ul&gt;
      &lt;li&gt;Actions these model the actions of the problem domain. In our model the domain actions are modeled as allowed transitions between state.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Initial or start state and goal
    &lt;ul&gt;
      &lt;li&gt;The initial state and the finial goal state (or goal condition)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heuristics
    &lt;ul&gt;
      &lt;li&gt;Things to guide the search process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;algorithms&quot;&gt;Algorithms&lt;/h2&gt;

&lt;p&gt;Once the problem has been formulated, we can use various algorithms to solve the problem.&lt;/p&gt;

&lt;h2 id=&quot;knowledge-states&quot;&gt;Knowledge States&lt;/h2&gt;

&lt;p&gt;States need not map directly to world configurations. Instead, a state could map to knowledge states. A knowledge state is a set of world states, every world state that you believe to be possible.&lt;/p&gt;

&lt;p&gt;If you look at every world state in a knowledge state, and ask what is true in every one of them, that that is the fact you know.&lt;/p&gt;

&lt;p&gt;If the agent knows nothing, the every world state is within the knowledge state.&lt;/p&gt;

&lt;h2 id=&quot;more-complex-situations&quot;&gt;More Complex Situations&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Actions can lead to multiple states: flip a coin
    &lt;ul&gt;
      &lt;li&gt;This lead to probabilistic models that we will discuss later&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Agent might be equipped with sensing actions
    &lt;ul&gt;
      &lt;li&gt;Solution could contain branches, for example if dirt then suck.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Search lecture 2&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;algorithms-for-search&quot;&gt;Algorithms for Search&lt;/h2&gt;

&lt;p&gt;AI search algorithms work with implicitly defined state spaces. There are typically an exponential number of states, which means we are impossible to explicitly define them all.&lt;/p&gt;

&lt;p&gt;Usually we only construct states we need to. Hence the actions are given as compact successor state functions that when given a state x return the set of state S can be transformed to by the available actions.
    * This means that the state must contain enough information to allow the successor state function to perform its computation.&lt;/p&gt;

&lt;p&gt;Inputs for search&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a specified initial state I&lt;/li&gt;
  &lt;li&gt;a successor function S(x) yields the set of all states action pairs (y,a) such that state y can be reached from x by applying an action a. The successor function returns all states reachable by a single action from state x.&lt;/li&gt;
  &lt;li&gt;a goal test function G(x) that can be applied to a state x and returns true if x satisfies the goal condition.&lt;/li&gt;
  &lt;li&gt;an action cost function C(x,a,y) which determines the cost of moving from state x to state y using action a.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Output of search&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;a sequence of actions that transforms the initial state to a state satisfying the goal test.
    &lt;ul&gt;
      &lt;li&gt;or just the sequence of states that arise from these actions.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Depending on the algorithm, different output maybe outputted.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A path in the search space is a sequence of states connected by actions. The cost of the path is simply the sum of all costs (the cost function C).&lt;/p&gt;

&lt;p&gt;Paths can be stored as a pair containing the final state of the path and a pointer to the previous state.&lt;/p&gt;

&lt;p&gt;We maintain a set of paths called the OPEN set (or frontier). Initially we set OPEN = {\&amp;lt;Start State\&amp;gt;}.&lt;/p&gt;

&lt;p&gt;At each step we select a path p from OPEN.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Check if p.final() satisfies the goal.&lt;/li&gt;
  &lt;li&gt;If not we add all extensions of p to OPEN
    &lt;ul&gt;
      &lt;li&gt;for all successor states y in S(p.final()), create a new path p_y = \&amp;lt;p,y\&amp;gt; (extend the path p to include a transition to the state y).&lt;/li&gt;
      &lt;li&gt;Remember to remove p&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goal&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extract&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# remove path from OPEN
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;goal&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;final&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;final&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()):&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;succ&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;false&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When a path p is extracted from open, we say that the algorithm expands p.&lt;/p&gt;

&lt;p&gt;The order paths are selected from OPEN has a critical effect on the operation of the search:
    * Whether or not a solution is found
    * The cost of the solution found
    * The time and space required by the search&lt;/p&gt;

&lt;p&gt;Basically we are asking how to order the OPEN set.&lt;/p&gt;

&lt;h2 id=&quot;critical-properties-of-search&quot;&gt;Critical Properties of Search&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Completeness
    &lt;ul&gt;
      &lt;li&gt;Will the search always find a solution if a solution exists?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Optimality
    &lt;ul&gt;
      &lt;li&gt;will the search always find the least cost solution?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Time complexity
    &lt;ul&gt;
      &lt;li&gt;what is the maximum number of paths that can be expanded or generated?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Space complexity
    &lt;ul&gt;
      &lt;li&gt;maximum number of path that are put on OPEN&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;uninformed-search-strategies&quot;&gt;Uninformed Search Strategies&lt;/h2&gt;

&lt;p&gt;These are strategies that adopt a fixed rule for selecting the next state to be expanded.&lt;/p&gt;

&lt;p&gt;For example: BFS, Uniform Cost, DFS, Depth Limited, Iterative Deepening Search.&lt;/p&gt;

&lt;h3 id=&quot;breadth-first-search&quot;&gt;Breadth First Search&lt;/h3&gt;

&lt;p&gt;Place the new paths that extend the current path at the end of OPEN. OPEN is a queue. Always extract first element of OPEN.&lt;/p&gt;

&lt;p&gt;Completeness? Yes, we will examine all paths, so we will find a solution if it exists. (but we might have a infinite layer).&lt;/p&gt;

&lt;p&gt;Optimality? Not really, however we do always find the shortest solution.&lt;/p&gt;

&lt;p&gt;Time complexity? Let b be the maximum number of successors of any state (maximal branching factor). Let d be the depth of the shortest solution. The time complexity is $O(b^{d+1})$.&lt;/p&gt;

&lt;p&gt;Space complexity? $O(b^{d+1})$&lt;/p&gt;

&lt;p&gt;BFS typically run out of space before we run out of time in most applications.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0mSXpyo69P7qnaHI0j6qRmpcDEXXFk2o0B/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Search lecture 3&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;uniform-cost-search&quot;&gt;Uniform-Cost Search&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Keep OPEN ordered by increasing cost of the path.&lt;/li&gt;
  &lt;li&gt;Always expand the least cost path.&lt;/li&gt;
  &lt;li&gt;Identical to breadth first if each action has the same cost.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Can use a min-heap to achieve this.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Completeness?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If each transition has costs $\geq \epsilon &amp;gt; 0$&lt;/li&gt;
  &lt;li&gt;Argument for BFS holds here&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Optimality?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Finds optimal solution if each transition has cost $\geq \epsilon &amp;gt; 0$&lt;/li&gt;
  &lt;li&gt;Explores paths in the search space in increasing order of cost. So must find minimum cost path to a goal before finding any higher costs paths leading to a goal.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="csc384" /><category term="csc384" /><category term="course-notes" /><summary type="html"></summary></entry><entry><title type="html">Word Break II</title><link href="https://jackzh.com/codingpractices/2020/02/24/word-break-ii.html" rel="alternate" type="text/html" title="Word Break II" /><published>2020-02-24T16:12:00-06:00</published><updated>2020-02-24T16:12:00-06:00</updated><id>https://jackzh.com/codingpractices/2020/02/24/word-break-ii</id><content type="html" xml:base="https://jackzh.com/codingpractices/2020/02/24/word-break-ii.html">&lt;p&gt;The main optimization for this is the memo. Because the problem is recursive, we simply remember the result of sub-problems.&lt;/p&gt;

&lt;p&gt;Actual problem can be found &lt;a href=&quot;https://leetcode.com/problems/word-break-ii/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wordBreak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recursiveSolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wordDict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;recursiveSolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;# Find all valid prefixes
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;# print(str(i) + &quot; &quot; + str(len(s)) + &quot; &quot; + s + &quot; &quot; + s[i:] + &quot; &quot; + s[:i])
&lt;/span&gt;                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:])&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;subResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recursiveSolution&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wordSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="codingpractices" /><category term="codingpractices" /><summary type="html">The main optimization for this is the memo. Because the problem is recursive, we simply remember the result of sub-problems. Actual problem can be found here. class Solution: def wordBreak(self, s: str, wordDict: List[str]) -&amp;gt; List[str]: self.memo = {} return self.recursiveSolution(0, len(s), s, set(wordDict)) def recursiveSolution(self, start, end, s, wordSet): # Find all valid prefixes if start in self.memo: return self.memo[start] result = [] for i in range(start, end + 1): if s[start:i] in wordSet: # print(str(i) + &quot; &quot; + str(len(s)) + &quot; &quot; + s + &quot; &quot; + s[i:] + &quot; &quot; + s[:i]) if i == end: result.append(s[start:]) else: subResult = self.recursiveSolution(i, end, s, wordSet) for sub in subResult: result.append(s[start:i] + ' ' + sub) self.memo[start] = result return result</summary></entry><entry><title type="html">Recover From Preorder Traversal</title><link href="https://jackzh.com/codingpractices/2020/02/23/recover-from-preorder-traversal.html" rel="alternate" type="text/html" title="Recover From Preorder Traversal" /><published>2020-02-23T08:26:00-06:00</published><updated>2020-02-23T08:26:00-06:00</updated><id>https://jackzh.com/codingpractices/2020/02/23/recover-from-preorder-traversal</id><content type="html" xml:base="https://jackzh.com/codingpractices/2020/02/23/recover-from-preorder-traversal.html">&lt;p&gt;The actual question can be found &lt;a href=&quot;https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Coded in less than 30 minutes, don’t expect it to be very good, I might optimize this later.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Solution&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;recoverFromPreorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// This is a recursive solution&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numericStartingIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rootVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;numericStartingIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;rootVal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rootVal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
            
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foundDepthOne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;atRight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numericStartingIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;charAt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// If this depth is the same or less than max depth&lt;/span&gt;
                    &lt;span class=&quot;c1&quot;&gt;// then we have to switch from left to right&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foundDepthOne&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;foundDepthOne&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;atRight&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atRight&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addNodeToString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addNodeToString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;currDepth&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recoverFromPreorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recoverFromPreorder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addNodeToString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;depth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'-'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="codingpractices" /><category term="codingpractices" /><summary type="html">The actual question can be found here Coded in less than 30 minutes, don’t expect it to be very good, I might optimize this later. /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode recoverFromPreorder(String S) { // This is a recursive solution if(S.length() == 0) return null; if(!S.contains(&quot;-&quot;)) { return new TreeNode(Integer.parseInt(S)); } else { int numericStartingIndex = 0; String rootVal = &quot;&quot;; for(int i = 0; i &amp;lt; S.length(); i++) { if(S.charAt(i) == '-') { numericStartingIndex = i; break; } else { rootVal += S.charAt(i); } } TreeNode node = new TreeNode(Integer.parseInt(rootVal)); boolean foundDepthOne = false; int currDepth = 0; boolean atRight = false; String left = &quot;&quot;; String right = &quot;&quot;; for(int i = numericStartingIndex; i &amp;lt; S.length(); i++) { if(S.charAt(i) == '-') { currDepth++; } else { char value = S.charAt(i); // If this depth is the same or less than max depth // then we have to switch from left to right if(currDepth == 1) { if(!foundDepthOne) { foundDepthOne = true; } else { atRight = true; } } if(atRight) { right = addNodeToString(right, value, currDepth - 1); } else { left = addNodeToString(left, value, currDepth - 1); } currDepth = 0; } } node.left = recoverFromPreorder(left); node.right = recoverFromPreorder(right); return node; } } public String addNodeToString(String curr, char value, int depth) { for(int i = 0; i &amp;lt; depth; i++) { curr += '-'; } curr += value; return curr; } }</summary></entry><entry><title type="html">CSCD58 Computer Networks - Routing</title><link href="https://jackzh.com/cscd58/2019/10/20/cscd58-routing.html" rel="alternate" type="text/html" title="CSCD58 Computer Networks - Routing" /><published>2019-10-20T09:26:00-05:00</published><updated>2019-10-20T09:26:00-05:00</updated><id>https://jackzh.com/cscd58/2019/10/20/cscd58-routing</id><content type="html" xml:base="https://jackzh.com/cscd58/2019/10/20/cscd58-routing.html">&lt;p&gt;Routers&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;With routers, computer network do hop-by-hop packet forwarding.&lt;/p&gt;

&lt;p&gt;Which means each router has a forwarding table that maps destination addresses to outgoing interfaces. And upon receiving a packet, it checks the table and sends out the packet. Next router in the path repeats.&lt;/p&gt;

&lt;h2 id=&quot;forwarding&quot;&gt;Forwarding&lt;/h2&gt;

&lt;h3 id=&quot;forwarding-in-ip-router&quot;&gt;Forwarding in IP Router&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Lookup packet destination address in table.
    &lt;ul&gt;
      &lt;li&gt;If unknown, drop the packet&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Decrement TTL, update header checksum&lt;/li&gt;
  &lt;li&gt;Forward packet to outgoing interface&lt;/li&gt;
  &lt;li&gt;Transmit packet onto link&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are many ways to construct the forwarding table.&lt;/p&gt;

&lt;h3 id=&quot;seperate-table-entries-per-address&quot;&gt;Seperate Table Entries Per Address&lt;/h3&gt;

&lt;p&gt;Matches destination address of incoming packet to the forwarding table entry, and it should always points directly to an interface.&lt;/p&gt;

&lt;p&gt;But this can lead to very large tables.&lt;/p&gt;

&lt;h3 id=&quot;seperate-entry-class-based-address&quot;&gt;Seperate Entry Class-Based Address&lt;/h3&gt;

&lt;p&gt;We can easily identify the mask from the address&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, class A /8&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;, class B /16&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;110&lt;/code&gt;, class C /24&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We can then just look in the forwarding table for matches.&lt;/p&gt;

&lt;p&gt;For example 1.2.3.4 matches to 1.2.3.0/8, then we lookup for 1.0.0.0/8&lt;/p&gt;

&lt;h3 id=&quot;longest-prefix-match-forwarding&quot;&gt;Longest Prefix Match Forwarding&lt;/h3&gt;

&lt;p&gt;With CIDR, an address can match multiple masks. Usually inside IP router, we map each IP prefix to next-hop links.&lt;/p&gt;

&lt;p&gt;We always do the logest match, for example 1.2.3.4 would match both 1.2.0.0/16 and 1.2.3.0/24, in this case we always match /24.&lt;/p&gt;

&lt;h4 id=&quot;linear-algorithm&quot;&gt;Linear Algorithm&lt;/h4&gt;

&lt;p&gt;We can simply scan each entry and see if address matches, however this is way too slow. With 10Gbps network and 40B packet, we need 31.25 Mpps performance!&lt;/p&gt;

&lt;h4 id=&quot;fast-lookups&quot;&gt;Fast Lookups&lt;/h4&gt;

&lt;p&gt;There are algorithms that is faster, but we can also use hardware&lt;/p&gt;

&lt;p&gt;Content Addressable Memories is one of them, it allows very fast lookups on a key.&lt;/p&gt;

&lt;h3 id=&quot;other-technologies&quot;&gt;Other Technologies&lt;/h3&gt;

&lt;p&gt;Routers have forwarding tables, and you can manually configure each entry.&lt;/p&gt;

&lt;p&gt;However it doesn’t adapt to failures, new equipment and the need to balance load etc.&lt;/p&gt;

&lt;p&gt;That is where routing protocols, DHCP and ARP comes in.&lt;/p&gt;

&lt;h2 id=&quot;routing-techniques&quot;&gt;Routing Techniques&lt;/h2&gt;

&lt;p&gt;How do we choose the shortest and fastest path?&lt;/p&gt;

&lt;p&gt;Forwarding simply forwards a data packet to an outgoing link, but routing is much more complex, routers have to talk to each other to compute the path.&lt;/p&gt;

&lt;h3 id=&quot;why-optimize-routing&quot;&gt;Why Optimize Routing&lt;/h3&gt;

&lt;p&gt;End-to-End Performance&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Quality of the path affects user performance&lt;/li&gt;
  &lt;li&gt;Delays, throughputs and packet losses&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Use of network resources&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;You prob don’t want to route through a jammed route&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Transient disruptions during changes&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Allows us to route through other routes when changes happen&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;naive-approach-flood&quot;&gt;Naive Approach (Flood)&lt;/h3&gt;

&lt;p&gt;Just send packets to all ports.&lt;/p&gt;

&lt;p&gt;It is pretty inefficient, and has the problem with spanning tree again.&lt;/p&gt;

&lt;h3 id=&quot;distance-vector-distributed-bellman-ford-algorithm&quot;&gt;Distance Vector Distributed Bellman-Ford Algorithm&lt;/h3&gt;

&lt;p&gt;Define distances at each node x such that d_x(y) is the cost of least-cost path from x to y.&lt;/p&gt;

&lt;p&gt;d_x(y) = min{c(x,v) = d_v(y)} over all neighbors v.&lt;/p&gt;

&lt;p&gt;Essentially, node x maintains costs of direct links from x to v.&lt;/p&gt;

&lt;p&gt;Node x also maintains the distance vector from x to y, which is an estimate of least cost.&lt;/p&gt;

&lt;p&gt;Node x maintains its neighbors’ distance vectors to y.&lt;/p&gt;

&lt;p&gt;Each node v periodically sends its own distance vector x to y to its neighbors, ad neighbors updates their estimate.&lt;/p&gt;

&lt;p&gt;Overtime the distance vector will converge.&lt;/p&gt;

&lt;h4 id=&quot;properties&quot;&gt;Properties&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Iterative, asynchronous, each local iteration is caused by
    &lt;ul&gt;
      &lt;li&gt;Local link cost change&lt;/li&gt;
      &lt;li&gt;Distnace vector update message from neighbor&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Distributed
    &lt;ul&gt;
      &lt;li&gt;Each node notifies neighbors only when its DV changes&lt;/li&gt;
      &lt;li&gt;Neighbors then notify their neighbors if necessary&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But have couting to infinity problem.
&lt;strong&gt;TODO: Have to double check this&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;link-state-dijkstra&quot;&gt;Link State (Dijkstra)&lt;/h3&gt;

&lt;p&gt;Routers send out update messages whenever the state of an incident link changes.&lt;/p&gt;

&lt;p&gt;Based on all link state updates, each router calculates lowest cost path to all others.&lt;/p&gt;

&lt;p&gt;It will eventually find a spanning tree rooted at the router.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq1WjntGw9dOao0VmDCmKiEyd0KJ10GKRSIB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;how-do-we-flood-lsp&quot;&gt;How do we flood LSP?&lt;/h4&gt;

&lt;p&gt;LSP = Link State Packet&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It includes the ID of the router that created the LSP&lt;/li&gt;
  &lt;li&gt;List of directly connected neighbors and cost&lt;/li&gt;
  &lt;li&gt;Sequence number&lt;/li&gt;
  &lt;li&gt;TTL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To reliable flood the LSP we resend LSP over all links other than the incident link, if the sequence number is newer. Otherwise drop it.&lt;/p&gt;

&lt;h3 id=&quot;ls-vs-dv&quot;&gt;LS vs DV&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LS = Link State&lt;/li&gt;
  &lt;li&gt;DV = Distance Vector&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LS have more messages sent, DV only exchanges between neighbors.&lt;/p&gt;

&lt;p&gt;LS requires O(nE) messages and a O(n^2) algorithm. DV is usually slower tho, also have counting to infinity issue.&lt;/p&gt;

&lt;p&gt;LS advertise incorrect link cost, each node then simply update its own table.&lt;/p&gt;

&lt;p&gt;DV advertises incorrect path cost, which means error propogates, and might be slow to recover.&lt;/p&gt;</content><author><name></name></author><category term="cscd58" /><category term="cscd58" /><category term="course-notes" /><summary type="html">Routers</summary></entry><entry><title type="html">CSCD58 Computer Networks - Internet Protocol</title><link href="https://jackzh.com/cscd58/2019/10/18/cscd58-internet-protocol.html" rel="alternate" type="text/html" title="CSCD58 Computer Networks - Internet Protocol" /><published>2019-10-18T12:18:00-05:00</published><updated>2019-10-18T12:18:00-05:00</updated><id>https://jackzh.com/cscd58/2019/10/18/cscd58-internet-protocol</id><content type="html" xml:base="https://jackzh.com/cscd58/2019/10/18/cscd58-internet-protocol.html">&lt;p&gt;Introduction to ethernet and IP&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;ethernet-data-link-layer&quot;&gt;Ethernet (Data Link Layer)&lt;/h2&gt;

&lt;p&gt;Dominant wired LAN tech, first widely used as well.&lt;/p&gt;

&lt;p&gt;Simpler and cheaper than token LANs and ATM. Pretty fast as well.&lt;/p&gt;

&lt;h3 id=&quot;csmacd&quot;&gt;CSMA/CD&lt;/h3&gt;

&lt;p&gt;Carrier sense multiple access&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Wait until channel is idle to start transmission&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Collision detection&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Listen while transmitting, if there is a colltion, then abort and send jam signal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Usually ethernet do exponential back-off, if there was a collision, it waits for a random time before trying again.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;After mth collision, chookse K randomly from {0, …., 2^m-1}&lt;/li&gt;
  &lt;li&gt;and wait for k*512 bit times.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;limitation-on-length&quot;&gt;Limitation on Length&lt;/h3&gt;

&lt;p&gt;Suppose the latency on a network is &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;. And host A sends a packet to B, B will not see that packet until t+d, if a collision happens, then the earliest time A can know is t+2d.&lt;/p&gt;

&lt;p&gt;This imposes some restriction on ethernet:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Maximum length of the wire 2500m&lt;/li&gt;
  &lt;li&gt;Minimum length of the packet 512 bits&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;frame-structure&quot;&gt;Frame Structure&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Addresses: Source and destination MAC addresses
    &lt;ul&gt;
      &lt;li&gt;If destination address matches the adaptor, then all good, otherwise drop.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Type: Indicates higher layer protocol
    &lt;ul&gt;
      &lt;li&gt;Usually IP&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CRC: Error checking bits&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0xupKW_spOgq5Qa9lLak8WWp-qf0s_rr4B/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;connectionless-service&quot;&gt;Connectionless Service&lt;/h2&gt;

&lt;h3 id=&quot;connectionless&quot;&gt;Connectionless&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;No handshaking&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unreliable&quot;&gt;Unreliable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Receiving adapter doesn’t send ACKs or NACKs&lt;/li&gt;
  &lt;li&gt;Packets can have gaps&lt;/li&gt;
  &lt;li&gt;TCP will fill the gaps, otherwise the application will see them&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;switching-data&quot;&gt;Switching Data&lt;/h2&gt;

&lt;p&gt;Different device switch different things&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Physical layer: electrical signals&lt;/li&gt;
  &lt;li&gt;Link layer: frames&lt;/li&gt;
  &lt;li&gt;Network layer: packets&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;repeaters-physical&quot;&gt;Repeaters (Physical)&lt;/h3&gt;

&lt;p&gt;It basically monitors electrical signals on each LAN, and transmits an amplified copy. Used to increase network distance.&lt;/p&gt;

&lt;h3 id=&quot;hubs-physical&quot;&gt;Hubs (Physical)&lt;/h3&gt;

&lt;p&gt;Joins multiple input lines, can hold multiple line cards. Doesn’t necessarily amplify the signal, but I don’t see why not.&lt;/p&gt;

&lt;p&gt;However, repeaters and hubs have problems&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Huge collision domain&lt;/li&gt;
  &lt;li&gt;Cannot support multiple technologies&lt;/li&gt;
  &lt;li&gt;Still have limitations (still can’t go beyond 2500 meters on ethernet)
    &lt;ul&gt;
      &lt;li&gt;basically.. you are still in the same LAN!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bridges-link&quot;&gt;Bridges (Link)&lt;/h3&gt;

&lt;p&gt;Connects two or more LANs at the link layer.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Extracts destination address from the frame&lt;/li&gt;
  &lt;li&gt;Looks up destination in its own table&lt;/li&gt;
  &lt;li&gt;Forwards the frame&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;switches-link&quot;&gt;Switches (Link)&lt;/h3&gt;

&lt;p&gt;Basically bridges, but instead of connecting LANs it connects hosts.&lt;/p&gt;

&lt;h3 id=&quot;dedicated-access-and-full-duplex&quot;&gt;Dedicated Access and Full Duplex&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Dedicated access
    &lt;ul&gt;
      &lt;li&gt;Direct connection with the switch&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Full duplex
    &lt;ul&gt;
      &lt;li&gt;Connection can go both directions&lt;/li&gt;
      &lt;li&gt;So no more collision issue&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hubs-vs-switches&quot;&gt;Hubs vs Switches&lt;/h3&gt;

&lt;h4 id=&quot;advantages&quot;&gt;Advantages&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Only forwards frames to the correct host&lt;/li&gt;
  &lt;li&gt;Can extend the geographic span of the network&lt;/li&gt;
  &lt;li&gt;Improves privacy&lt;/li&gt;
  &lt;li&gt;Applies CSMA/CD&lt;/li&gt;
  &lt;li&gt;Can have different technologies&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;disadvantages&quot;&gt;Disadvantages&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Slower
    &lt;ul&gt;
      &lt;li&gt;Solution is cut-through switching&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Need to learn where to forward frames&lt;/li&gt;
  &lt;li&gt;Higher cost&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cut-through-switching&quot;&gt;Cut-Through Switching&lt;/h3&gt;

&lt;p&gt;Buffering a frame takes time, and the delay can be quite large compared to network delays.&lt;/p&gt;

&lt;p&gt;Basically two main points&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Start transmitting as soon as possible&lt;/li&gt;
  &lt;li&gt;Transmit the head of the packet while still receiving the tail (because head already tells you where to forward)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;self-learning&quot;&gt;Self Learning&lt;/h3&gt;

&lt;p&gt;We want to construct the switch table automatically.&lt;/p&gt;

&lt;p&gt;When a packet arrives, switch inpects the MAC address and associates that MAC with the incoming interface. Now the switch knows how to reach that host.&lt;/p&gt;

&lt;p&gt;If the switch doesn’t know where to send the packet, then it will just flood the network (send to every host).&lt;/p&gt;

&lt;h4 id=&quot;flooding-and-loops&quot;&gt;Flooding and Loops&lt;/h4&gt;

&lt;p&gt;Switches sometimes needs to broadcast frames. Which just means flooding.&lt;/p&gt;

&lt;p&gt;Flooding can lead to loops if there is a cycle of switches.&lt;/p&gt;

&lt;h4 id=&quot;spanning-trees&quot;&gt;Spanning Trees&lt;/h4&gt;

&lt;p&gt;A spanning tree makes sure the topology has no loops, switches needs to cooperate to build the spanning tree.&lt;/p&gt;

&lt;p&gt;The basic idea:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Elect a root (switch with smallest identifier)&lt;/li&gt;
  &lt;li&gt;Each switch checks if its interface is on the shortest path from the root
    &lt;ul&gt;
      &lt;li&gt;Excludes it from the tree if not&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Initially, each switch thinks it is the root
    &lt;ul&gt;
      &lt;li&gt;Sends out a message to every interface identifying itself as the root with distance of 0&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Upon receiving a message
    &lt;ul&gt;
      &lt;li&gt;Check root id, if smaller&lt;/li&gt;
      &lt;li&gt;Start viewing that switch as root&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Adds 1 to the distance received from a neighbor
    &lt;ul&gt;
      &lt;li&gt;Checks to see which interface is not on a shortest path to root&lt;/li&gt;
      &lt;li&gt;Exclude them&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;However algorithms can fail, here are some important things to note:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Failure of the root node
    &lt;ul&gt;
      &lt;li&gt;Must elect a new root&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Failure of other switches
    &lt;ul&gt;
      &lt;li&gt;Must recompute&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Root switch should periodically reannouncing itself as the root&lt;/li&gt;
  &lt;li&gt;Detecting failure through timeout
    &lt;ul&gt;
      &lt;li&gt;Wait to hear from others&lt;/li&gt;
      &lt;li&gt;If takes too long, just claims itself to be root&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;switches-vs-routers&quot;&gt;Switches vs Routers&lt;/h3&gt;

&lt;h4 id=&quot;advantages-1&quot;&gt;Advantages&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Plug and play&lt;/li&gt;
  &lt;li&gt;Fast filtering and forwarding&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;disadvantages-1&quot;&gt;Disadvantages&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Topology is restricted to spanning tree&lt;/li&gt;
  &lt;li&gt;Large networks require large ARP (address resolution protocol) tables&lt;/li&gt;
  &lt;li&gt;Broadcast storms can cause the network to collapse&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq1fMD0eDtlNAY3rRYYncgP2CCNMdVpTMXEB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-internet-protocol-ip&quot;&gt;The Internet Protocol (IP)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Connectionless&lt;/li&gt;
  &lt;li&gt;Unreliable&lt;/li&gt;
  &lt;li&gt;Best effort&lt;/li&gt;
  &lt;li&gt;Uses datagram&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0FEwPq2T5LaLDipyBS3DqEY2w8Ub4t-PcB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;fragmentation&quot;&gt;Fragmentation&lt;/h3&gt;

&lt;p&gt;A router may receive a packet larger than the maximum MTU of the outgoing link.&lt;/p&gt;

&lt;p&gt;Then it must seperate the datagram into multiple smaller ones.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Fragments are re-assembled by destination host, not intermediate routers.&lt;/li&gt;
  &lt;li&gt;Usually we use path MTU discovery to find the smallest MTU along the path.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ip-addresses&quot;&gt;IP Addresses&lt;/h3&gt;

&lt;p&gt;IPv4 are 32 bits long, every interface has a unique IP address. IPv6 are 128 bits long.&lt;/p&gt;

&lt;p&gt;IP addresses maybe assigned statically or dynamically (DHCP).&lt;/p&gt;

&lt;h4 id=&quot;classes&quot;&gt;Classes&lt;/h4&gt;

&lt;p&gt;Originally there were 5 classes&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A: Starts with &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 7 bit ID&lt;/li&gt;
  &lt;li&gt;B: Starts with &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;, 14 bit ID&lt;/li&gt;
  &lt;li&gt;C: Starts with &lt;code class=&quot;highlighter-rouge&quot;&gt;110&lt;/code&gt;, 21 bit ID&lt;/li&gt;
  &lt;li&gt;D: Starts with &lt;code class=&quot;highlighter-rouge&quot;&gt;1110&lt;/code&gt;, 28 bit multicast group ID&lt;/li&gt;
  &lt;li&gt;E: Starts with &lt;code class=&quot;highlighter-rouge&quot;&gt;11110&lt;/code&gt;, 27 bit reserved&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But this leads to many problems&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Address classes are too “regid”, A is too large, B is too small.&lt;/li&gt;
  &lt;li&gt;Internally might need a seperate network ID for each link.&lt;/li&gt;
  &lt;li&gt;Then the public needs to know them as well, very inefficient.&lt;/li&gt;
  &lt;li&gt;Small organizations wanted class B, but there are only 16,000 class B network IDs.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are two main solutions&lt;/p&gt;

&lt;h4 id=&quot;subnetting&quot;&gt;Subnetting&lt;/h4&gt;

&lt;p&gt;Subdivide the organization’s network ID&lt;/p&gt;

&lt;p&gt;Basically you go over your net ID and use first few bits of the host ID to divide up the network.&lt;/p&gt;

&lt;p&gt;Subnets are usually represented via an address plus a subet mask. &lt;code class=&quot;highlighter-rouge&quot;&gt;ffffff00&lt;/code&gt; if first 24 bits are the subnet ID, last 8 bits are the host ID.&lt;/p&gt;

&lt;h4 id=&quot;classless-inter-domain-routing-cidr&quot;&gt;Classless Inter-Domain Routing (CIDR)&lt;/h4&gt;

&lt;p&gt;IP space is broken into line segments.&lt;/p&gt;

&lt;p&gt;128.9.0.0/16 basically means the line segment containing addresses in teh range 128.9.0.0 - 128.9.255.255.&lt;/p&gt;

&lt;p&gt;Longer the prefix, smaller the network, thus more specific.&lt;/p&gt;

&lt;p&gt;Sometimes if an ISP serves two organizations with similar prefixes, it can sometimes aggregate them to form a shorter prefix, so other routers can have smaller tables.&lt;/p&gt;

&lt;p&gt;In principle, an organization can keep its prefix if it changes service providers.&lt;/p&gt;

&lt;h4 id=&quot;ipv6&quot;&gt;IPv6&lt;/h4&gt;

&lt;p&gt;128 bits, it uses 8 groups of 4 hex digits.&lt;/p&gt;

&lt;p&gt;Omit leading zeros and groups of zeros.&lt;/p&gt;

&lt;p&gt;so &lt;code class=&quot;highlighter-rouge&quot;&gt;2001:0db8:0000:0000:0000:ff00:0042:8329&lt;/code&gt; is basically &lt;code class=&quot;highlighter-rouge&quot;&gt;2001:0db8::ff00:0042:8329&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;ipv6-transition&quot;&gt;IPv6 Transition&lt;/h3&gt;

&lt;p&gt;How do we deploy IPv6? It is fundamentally incompatible with IPv4.&lt;/p&gt;

&lt;p&gt;There are many approaches&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Dual stack (both v4 and v6)&lt;/li&gt;
  &lt;li&gt;Translators (converts packets)&lt;/li&gt;
  &lt;li&gt;Tunnels (carrys IPv6 over IPv4)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;tunneling&quot;&gt;Tunneling&lt;/h4&gt;

&lt;p&gt;Basically, tunnel carries IPv6 packets across IPv4 network.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq0Zh9eH4CtMSqfFsiBHJhGI5WQIXhusb-8B/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;However it is hard to setup tunnel endpoints and routing.&lt;/p&gt;

&lt;h2 id=&quot;dns&quot;&gt;DNS&lt;/h2&gt;

&lt;p&gt;Names are hierarchical and belong to a domain. Top-level domains are assigned by the Internet Corporation of Assigned Names and Numbers (ICANN).&lt;/p&gt;

&lt;h3 id=&quot;dns-query&quot;&gt;DNS Query&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Client asks local server&lt;/li&gt;
  &lt;li&gt;If local doesn’t have address, asks the root server of the requested domain&lt;/li&gt;
  &lt;li&gt;Addresses are usually cached&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;icmp-internet-control-message-protocol&quot;&gt;ICMP (Internet Control Message Protocol)&lt;/h3&gt;

&lt;p&gt;Used by hosts and routers to communicate network-level information.&lt;/p&gt;

&lt;p&gt;ICMP is carried in IP datagrams.&lt;/p&gt;

&lt;p&gt;It includes type, code plus first 8 bytes of IP datagram causing error.&lt;/p&gt;

&lt;h3 id=&quot;traceroute&quot;&gt;Traceroute&lt;/h3&gt;

&lt;p&gt;The source sends series of UDP segments to destination&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;TTL = 1,2,3…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When datagram in nth set arrives to nth router, the router discards datagram and sends source an ICMP message of type 11, code 0, also includes name and IP.&lt;/p&gt;

&lt;p&gt;When ICMP arrives, source records RTT.&lt;/p&gt;

&lt;p&gt;It will eventually arrive at destination host. Destination will return ICMP port unreachable (type 3, code 3), then source stops.&lt;/p&gt;</content><author><name></name></author><category term="cscd58" /><category term="cscd58" /><category term="course-notes" /><summary type="html">Introduction to ethernet and IP</summary></entry><entry><title type="html">CSCD58 Computer Networks - Link Layer</title><link href="https://jackzh.com/cscd58/2019/10/17/cscd58-link-layer.html" rel="alternate" type="text/html" title="CSCD58 Computer Networks - Link Layer" /><published>2019-10-17T19:22:00-05:00</published><updated>2019-10-17T19:22:00-05:00</updated><id>https://jackzh.com/cscd58/2019/10/17/cscd58-link-layer</id><content type="html" xml:base="https://jackzh.com/cscd58/2019/10/17/cscd58-link-layer.html">&lt;p&gt;Physical links and error correction/detection&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;How do we send messages across a wire?&lt;/p&gt;

&lt;p&gt;Hosts and routers are called &lt;em&gt;nodes&lt;/em&gt;, and the communication path are called &lt;em&gt;links&lt;/em&gt;. A frame encapsulates the datagram and sends the data through a link.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Application
Presentation
Session
Transport
Network
Data Link       &amp;lt;- Network cards etc.
Physical        &amp;lt;- Ethernet cables, wireless signals
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;data link&lt;/em&gt; layer is responsible for transferring datagram from one node to physically adjacent node over a physical link.&lt;/p&gt;

&lt;p&gt;A datagram maybe transferred to final destination using many different links, and they may have different protocols. &lt;em&gt;Routing algorithm&lt;/em&gt; decides which path to take to get the datagram to final destination.&lt;/p&gt;

&lt;h2 id=&quot;common-link-layer-services&quot;&gt;Common Link Layer Services&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Note: link layers may provide more services, these are just examples.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;framing&quot;&gt;Framing&lt;/h3&gt;

&lt;p&gt;Encapsulate datagram into frames, adding header, trailer (for example addresses and error-correction bits).&lt;/p&gt;

&lt;h3 id=&quot;link-access&quot;&gt;Link Access&lt;/h3&gt;

&lt;p&gt;Allows upper layers to access links, channel if shared medium.&lt;/p&gt;

&lt;p&gt;MAC (Media Access Control) address is used to identify source, destination. This address uniquely identifies each device on a network.&lt;/p&gt;

&lt;h3 id=&quot;reliable-delivery&quot;&gt;Reliable Delivery&lt;/h3&gt;

&lt;p&gt;Usually error correction is not implemented on low error links (fiber, some twisted pairs).&lt;/p&gt;

&lt;p&gt;But wireless has high error-rate, so error correction is implemented on link layer.&lt;/p&gt;

&lt;h2 id=&quot;common-physical-media&quot;&gt;Common Physical Media&lt;/h2&gt;

&lt;h3 id=&quot;twisted-pairs&quot;&gt;Twisted Pairs&lt;/h3&gt;

&lt;p&gt;Usually max 100m.&lt;/p&gt;

&lt;p&gt;CAT5 (most common), supports up to Gigabit ethernet.&lt;/p&gt;

&lt;p&gt;CAT6, 6a, 7 can support 10Gbps, 40Gbps, 100Gbps.&lt;/p&gt;

&lt;h3 id=&quot;coaxial-cable&quot;&gt;Coaxial Cable&lt;/h3&gt;

&lt;p&gt;Usually max 200m.&lt;/p&gt;

&lt;p&gt;But very slow, usually just 10Mbps (why would anyone use this???).&lt;/p&gt;

&lt;h3 id=&quot;fibre-optic-cables&quot;&gt;Fibre Optic Cables&lt;/h3&gt;

&lt;h4 id=&quot;single-mode&quot;&gt;Single-Mode&lt;/h4&gt;

&lt;p&gt;Very narrow core. 10um, light can’t even bounce around within the core.&lt;/p&gt;

&lt;p&gt;Used with lasers for long distances (100km).&lt;/p&gt;

&lt;h4 id=&quot;multi-mode&quot;&gt;Multi-Mode&lt;/h4&gt;

&lt;p&gt;Light can bounce within the core (50um). Used with LEDs for shorter distances, cannot go longer because modal dispersion.&lt;/p&gt;

&lt;h3 id=&quot;fiber&quot;&gt;Fiber&lt;/h3&gt;

&lt;p&gt;Long, thin, pure strand of glass.&lt;/p&gt;

&lt;p&gt;Light propogated through internal reflection, huge bandwidth, can reach 100 petabits/kilometer/sec (Bell Labs).&lt;/p&gt;

&lt;h3 id=&quot;wireless&quot;&gt;Wireless&lt;/h3&gt;

&lt;p&gt;Different frequencies have different properties, and are subject to environmental effects.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Signals decrease as it propogates through matter.&lt;/li&gt;
  &lt;li&gt;Other sources can interfere (for example 2.4Ghz, worst garbage ever).&lt;/li&gt;
  &lt;li&gt;Multipath propogation, signal reflects off objects, so they can arrive at destination at slightly different times.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;bandwidth-of-a-channel&quot;&gt;Bandwidth of a Channel&lt;/h2&gt;

&lt;p&gt;There are two main definitions of bandwidths:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B, in Hz, is the width of the pass-band in the frequency domain&lt;/li&gt;
  &lt;li&gt;bps, is the information carrying capacity of the channel&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;They are related to noise, noise limits how many signal levels can we safely distinguish.&lt;/p&gt;

&lt;h2 id=&quot;encoding-bits&quot;&gt;Encoding Bits&lt;/h2&gt;

&lt;p&gt;Generate analog waveform from transmitter and sample at receiver.&lt;/p&gt;

&lt;p&gt;Signal transition rate = Baud rate / Versus bit rate&lt;/p&gt;

&lt;h3 id=&quot;nrz&quot;&gt;NRZ&lt;/h3&gt;

&lt;p&gt;Simplest encoding, Non-Return to Zero. High = 1, Low = 0.&lt;/p&gt;

&lt;h3 id=&quot;nrzi&quot;&gt;NRZI&lt;/h3&gt;

&lt;p&gt;Transition for 1s, no transition for 0s.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zAXrdUb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;clock-recovery&quot;&gt;Clock Recovery&lt;/h2&gt;

&lt;p&gt;How can we distinguish consecutive 0s or 1s?&lt;/p&gt;

&lt;p&gt;Sender and receivers won’t always have the same clock&lt;/p&gt;

&lt;p&gt;There are a few solutions to this problem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Send a seperate clock signal -&amp;gt; Expensive&lt;/li&gt;
  &lt;li&gt;Keep messages short -&amp;gt; Limits data rate&lt;/li&gt;
  &lt;li&gt;Embed clock signal in data signal&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;manchester-coding&quot;&gt;Manchester Coding&lt;/h3&gt;

&lt;p&gt;Make transition in the middle of every bit period.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Low-to-High is 0, High-to-Low is 1.&lt;/li&gt;
  &lt;li&gt;Used in 10Mbps ethernet.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is self-clocking, XOR of NRZ encoding. However it has 50% efficiency.&lt;/p&gt;

&lt;h3 id=&quot;4b5b-codes&quot;&gt;4B/5B Codes&lt;/h3&gt;

&lt;p&gt;Maps 4 bits to 5 bits, and ensures never 3 consecutive 0s back-to-back. 80% efficiency.&lt;/p&gt;

&lt;p&gt;Used in LANs (FDDI, 100Mbps ethernet).&lt;/p&gt;

&lt;h2 id=&quot;framing-1&quot;&gt;Framing&lt;/h2&gt;

&lt;p&gt;We need to send messages, not bits (requires synchronization). Adaptors allows hosts to exchange frames through links.&lt;/p&gt;

&lt;h3 id=&quot;ppp-point-to-point-protocol&quot;&gt;PPP Point-to-Point Protocol&lt;/h3&gt;

&lt;p&gt;Flag is &lt;code class=&quot;highlighter-rouge&quot;&gt;0x7E&lt;/code&gt;, it indicate the start and end of of frames.&lt;/p&gt;

&lt;p&gt;If payload contains this flag, it must be “stuffed” (escaped).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0x7E -&amp;gt; 0x7D, 0x5E&lt;/li&gt;
  &lt;li&gt;0x7D -&amp;gt; 0x7D, 0x5D&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;latency&quot;&gt;Latency&lt;/h2&gt;

&lt;p&gt;How long does it take to send a message.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Propagation delay = distance / speed of light in media
    &lt;ul&gt;
      &lt;li&gt;How long does it take for 1 bit to travel.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Transmission delay = message size / rate
    &lt;ul&gt;
      &lt;li&gt;How quickly can you get the message onto the wire.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Latency = Propogation Delay + Transmission Delay&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jISgrP1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;RTT (Round-Trip-Time) is just twice the one way delay.&lt;/p&gt;

&lt;h2 id=&quot;throughput&quot;&gt;Throughput&lt;/h2&gt;

&lt;p&gt;Measure of system’s ability to pumpout data (not bandwidth).&lt;/p&gt;

&lt;p&gt;Throughput = Transfer Size / Transfer Time.&lt;/p&gt;

&lt;h2 id=&quot;bandwidth-delay-product&quot;&gt;Bandwidth Delay Product&lt;/h2&gt;

&lt;p&gt;This indicates how many bits can the network “store” in any given time.&lt;/p&gt;

&lt;p&gt;Suppose latency is 16 seconds, and the bandwidth is 1b/s, then the BDP is 1b/s * 16s = 16 bits.&lt;/p&gt;

&lt;p&gt;Tells us how much data can be sent before a receiver sees any of it. 2x BDP means how much data we could send before hearing back about the first bit. Rule of thumb for sizing router buffers.&lt;/p&gt;

&lt;h2 id=&quot;packet-switching&quot;&gt;Packet Switching&lt;/h2&gt;

&lt;p&gt;End to end latency is latency of all routers added together.&lt;/p&gt;

&lt;p&gt;Packet switching allows parallel transmission across all links, reducing latendy while also prevents a link from being “hogged” for a long time by one message. This is essentially the exact same idea as memory paging.&lt;/p&gt;

&lt;h3 id=&quot;queueing-delay&quot;&gt;Queueing Delay&lt;/h3&gt;

&lt;p&gt;Network might be busy when a packet arrives, so the actual end to end latency is&lt;/p&gt;

&lt;p&gt;Transmission Delay + Propogation Delay + Queueing Delay&lt;/p&gt;

&lt;h2 id=&quot;error-detection-and-correction&quot;&gt;Error Detection and Correction&lt;/h2&gt;

&lt;p&gt;Link may transmit garbage, how can we detect errors when it arrives?&lt;/p&gt;

&lt;p&gt;This is the responsibility of multiple layers:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Transport&lt;/li&gt;
  &lt;li&gt;Network&lt;/li&gt;
  &lt;li&gt;Data Link&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Physical is not included because ofc, physical is what causes error.&lt;/p&gt;

&lt;p&gt;We can add redundant data&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error detection codes: Allows errors to be recognized&lt;/li&gt;
  &lt;li&gt;Error correction codes: Allows errors to be repaired&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Basic block codes????? page 42&lt;/p&gt;

&lt;h3 id=&quot;strategies-to-correct-errors&quot;&gt;Strategies to Correct Errors&lt;/h3&gt;

&lt;p&gt;There are two main strategies&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Detect and retransmit, or Automatic Repeat Request (ARQ)&lt;/li&gt;
  &lt;li&gt;Use error correcting codes, or Forward Error Correction (FEC)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Real-time media tend to use error correction because it is faster.&lt;/p&gt;

&lt;p&gt;Higher levels (network+) may use retransmissions (less error, doesn’t make sense to include codes).&lt;/p&gt;

&lt;p&gt;Most data networks today use error detection, not correction, because less overhead. But really depends on the application and error characteristics.&lt;/p&gt;

&lt;h4 id=&quot;common-correction-codes&quot;&gt;Common Correction Codes&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Hamming Codes&lt;/li&gt;
  &lt;li&gt;Binary Convolutional Codes&lt;/li&gt;
  &lt;li&gt;Reed-Solomon and Low-Density Parity Check Codes
    &lt;ul&gt;
      &lt;li&gt;Complex, but widely used&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;common-detection-codes&quot;&gt;Common Detection Codes&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Parity&lt;/li&gt;
  &lt;li&gt;Checksums&lt;/li&gt;
  &lt;li&gt;Cyclic redundancy codes&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-hamming-distance&quot;&gt;The Hamming Distance&lt;/h3&gt;

&lt;p&gt;If an error turns one valid codeword into another valid one, then we cannot detect/correct them.&lt;/p&gt;

&lt;p&gt;Hamming distance of a code is the smallest number of bit differences that turn any one codeword into another.&lt;/p&gt;

&lt;p&gt;So for example 000/111 has HD of 3.&lt;/p&gt;

&lt;p&gt;If we define our error detection code as a simple duplication, then the HD is 2 because all valid words must have at least 2 bits different.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HD d+1
    &lt;ul&gt;
      &lt;li&gt;d errors can be detected&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HD 2d+1
    &lt;ul&gt;
      &lt;li&gt;d errors can be corrected&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;parity&quot;&gt;Parity&lt;/h3&gt;

&lt;p&gt;Start with n bits and add another so that total number of 1s is even (even parity).&lt;/p&gt;

&lt;p&gt;Cannot detect even number of bit errors. Pretty bad, don’t use this garbage.&lt;/p&gt;

&lt;p&gt;Random errors are detected with probability of 1/2.&lt;/p&gt;

&lt;h4 id=&quot;2d-parity&quot;&gt;2D Parity&lt;/h4&gt;

&lt;p&gt;Make the message a grid of bits, and add parity bits to each row and column.&lt;/p&gt;

&lt;p&gt;n-D parity can usually correct n-1 errors.&lt;/p&gt;

&lt;p&gt;2D parity detects all 1,2,3 bit errors, and many with &amp;gt;3 bits.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq2gGg1AeyBPrbWI1-XhWweMYrvIZ9ESY9sB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;checksums&quot;&gt;Checksums&lt;/h3&gt;

&lt;p&gt;Widely used in IP, ICMP, TCP, UDP.&lt;/p&gt;

&lt;p&gt;Checksum is the 1s complement of the 1s complement sum of the data interpreted 16 bits at a time (for 16-bit checksums).&lt;/p&gt;

&lt;p&gt;Example: 4-bit checksum&lt;/p&gt;

&lt;p&gt;Say we have the message 101101111010, first we divide it up to 4 bits segments&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1011
0111
1010
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and then we add them&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1011
+ 0111
  0010  with 1 carry
  0011
+ 1010
  1101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then the 1s complement of 1101, which is 0010 is our checksum.&lt;/p&gt;

&lt;p&gt;On the receiver, we just add all of them&lt;/p&gt;

&lt;p&gt;1011 + 0111 + 1010 + 0010 = 1111, we are all good!&lt;/p&gt;

&lt;h3 id=&quot;crcs-cyclic-redundancy-check&quot;&gt;CRCs (Cyclic Redundancy Check)&lt;/h3&gt;

&lt;p&gt;Stronger then checksums, widely used in ethernet&lt;/p&gt;

&lt;p&gt;Given n bits of data, generate a k bit check sequence that gives a combined n + k bits that are divisible by a chosen divisor C(x).&lt;/p&gt;

&lt;p&gt;If we have 1001, interpret it as x^3 + x^0&lt;/p&gt;

&lt;p&gt;Following example uses message 10011010 and generator 1101 or x^3 + x^2 + x^0&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq3s-J8p2TBPpL1-4c8CnMaf0NRk-otyz3gB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Message to be sent is 10011010101, and it is divisible by 1101.&lt;/p&gt;

&lt;h3 id=&quot;reed-solomon--bch-codes&quot;&gt;Reed-Solomon / BCH Codes&lt;/h3&gt;

&lt;p&gt;Mainly used for magnetic disks.&lt;/p&gt;

&lt;p&gt;2t redundant bits can correct &amp;lt;= t errors.&lt;/p&gt;</content><author><name></name></author><category term="cscd58" /><category term="cscd58" /><category term="course-notes" /><summary type="html">Physical links and error correction/detection</summary></entry><entry><title type="html">CSCB63 Data Structure Design and Analysis - Fibonacci Heaps</title><link href="https://jackzh.com/cscb63/2019/03/12/cscb63-fib-heap.html" rel="alternate" type="text/html" title="CSCB63 Data Structure Design and Analysis - Fibonacci Heaps" /><published>2019-03-12T12:00:00-05:00</published><updated>2019-03-12T12:00:00-05:00</updated><id>https://jackzh.com/cscb63/2019/03/12/cscb63-fib-heap</id><content type="html" xml:base="https://jackzh.com/cscb63/2019/03/12/cscb63-fib-heap.html">&lt;p&gt;Basic introduction to fibonacci heaps and some comparson with regular heaps.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;operations-supported&quot;&gt;Operations Supported&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make_heap&lt;/code&gt; - Create a new heap.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;insert(H, x)&lt;/code&gt; - Insert &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; into heap &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;min(H)&lt;/code&gt; - Return minimum element in &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extract_min(H)&lt;/code&gt; - Return minimum element in &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; and removes it.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;union(H1, H2)&lt;/code&gt; - Creates and returns a new heap containing all elements in &lt;code class=&quot;highlighter-rouge&quot;&gt;H1&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;H2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;decrease_key(H, x, k)&lt;/code&gt; - Assigns &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt; a new key &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt; must be less then the current key.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;delete(H, x)&lt;/code&gt; - Delete element &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; from heap &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;complexity-comparsions-with-binary-heaps&quot;&gt;Complexity Comparsions With Binary-Heaps&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Binary Heap Worse-Case&lt;/th&gt;
      &lt;th&gt;Fib-Heap Amortized&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;insert&lt;/td&gt;
      &lt;td&gt;$\Theta(lgn)$&lt;/td&gt;
      &lt;td&gt;$\Theta(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;extract-min&lt;/td&gt;
      &lt;td&gt;$\Theta(lgn)$&lt;/td&gt;
      &lt;td&gt;$O(lgn)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;decrease-priority&lt;/td&gt;
      &lt;td&gt;$\Theta(lgn)$&lt;/td&gt;
      &lt;td&gt;$\Theta(1)$&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;union&lt;/td&gt;
      &lt;td&gt;$\Theta(n)$&lt;/td&gt;
      &lt;td&gt;$\Theta(1)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;structure&quot;&gt;Structure&lt;/h2&gt;

&lt;p&gt;A fibonnacci heap includes the following components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A forest of heap-ordered trees.&lt;/li&gt;
  &lt;li&gt;Roots of these trees are stored in a circular doubly-linked list.&lt;/li&gt;
  &lt;li&gt;Pointer to minimum root, and total number of nodes.&lt;/li&gt;
  &lt;li&gt;Siblings in a circular doubly-linked list, parent only knows one child.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;deg(x)&lt;/code&gt; is number of children is &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;’s child list.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://www.evernote.com/l/Aq1GyqY27zVE5YwiM4e_BM9NY38465L1RhEB/image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For each node, it contains following fields:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;key: Priority&lt;/li&gt;
  &lt;li&gt;left, right, parent: Pointers&lt;/li&gt;
  &lt;li&gt;child: Pointer to one child&lt;/li&gt;
  &lt;li&gt;degree: Num of children&lt;/li&gt;
  &lt;li&gt;mark: Boolean, useful for &lt;code class=&quot;highlighter-rouge&quot;&gt;decrease-priority&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;operations&quot;&gt;Operations&lt;/h2&gt;

&lt;h3 id=&quot;insert&quot;&gt;Insert&lt;/h3&gt;

&lt;p&gt;Insert is very simple, you simply insert into the root linked-list. This takes $O(1)$.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert(H, x) {
    node = new Node(x);
    node.marked = false;
    // Insert right after H.min
    node.right = H.min.right;
    node.left = H.min;
    H.min.right = node;
    node.right.left = node;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;union&quot;&gt;Union&lt;/h3&gt;

&lt;p&gt;Just merge two root lists and it is done. This also takes $O(1)$.&lt;/p&gt;

&lt;p&gt;Of course if you want to make a copy this takes longer.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;union(H1, H2) {
    connect H1.min and H2.min
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="cscb63" /><category term="cscb63" /><category term="course-notes" /><summary type="html">Basic introduction to fibonacci heaps and some comparson with regular heaps.</summary></entry><entry><title type="html">CSCC69 Operating Systems - Threads</title><link href="https://jackzh.com/cscc69/2019/02/13/cscc69-threads.html" rel="alternate" type="text/html" title="CSCC69 Operating Systems - Threads" /><published>2019-02-13T11:50:00-06:00</published><updated>2019-02-13T11:50:00-06:00</updated><id>https://jackzh.com/cscc69/2019/02/13/cscc69-threads</id><content type="html" xml:base="https://jackzh.com/cscc69/2019/02/13/cscc69-threads.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Threads are basically mini-processes within a process. However they share the same address space.&lt;/p&gt;

&lt;p&gt;Creating threads are much faster than creating processes, in some systems, this can be 10x to 100x faster.&lt;/p&gt;

&lt;p&gt;Think of threads as JS event loops, basically it.&lt;/p&gt;

&lt;h2 id=&quot;classic-thread-model&quot;&gt;Classic Thread Model&lt;/h2&gt;

&lt;p&gt;The classic thread model basically have all threads with their own stack and own PC.&lt;/p&gt;

&lt;p&gt;Everything else is shared. The software library will take care of scheduling.&lt;/p&gt;

&lt;h2 id=&quot;posix-thread-standard&quot;&gt;POSIX Thread Standard&lt;/h2&gt;

&lt;p&gt;Some useful calls:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pthread_create: New thread&lt;/li&gt;
  &lt;li&gt;pthread_exit: Quite the calling thread&lt;/li&gt;
  &lt;li&gt;pthread_join: Wait for a thread to exit&lt;/li&gt;
  &lt;li&gt;pthread_yield: Give up CPU for another thread&lt;/li&gt;
  &lt;li&gt;pthread_attr_init: Create a thread attribute structure&lt;/li&gt;
  &lt;li&gt;pthread_attr_destroy: Remove a thread’s attribute structure&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;user-space-thread-implementation&quot;&gt;User Space Thread Implementation&lt;/h2&gt;

&lt;p&gt;If implemented in user space, then the library have to take care of scheduling and switching. However if hardware do support store/load registers, this operation can be done very quickly, which is much faster than trapping to kernel.&lt;/p&gt;

&lt;p&gt;And since everything is local, no context switch is needed, no kernel calls, it is very fast. Each process can also have its own scheduling algorithm.&lt;/p&gt;

&lt;h3 id=&quot;drawbacks&quot;&gt;Drawbacks&lt;/h3&gt;

&lt;p&gt;Thread cannot make blocking kernel calls, since that will halt all threads. Sometimes library will wrap the actual system call, but it is not really that nice to do.&lt;/p&gt;

&lt;p&gt;Another issue is page fault. Which will be discussed in memory management (basically blocking the process because it needs to read instructions from disk).&lt;/p&gt;

&lt;p&gt;In user space thread implementations, there is no clock interrupts. So a thread must give up the CPU before another thread can be run.&lt;/p&gt;

&lt;h2 id=&quot;kernel-space-thread-implementation&quot;&gt;Kernel Space Thread Implementation&lt;/h2&gt;</content><author><name></name></author><category term="cscc69" /><category term="cscc69" /><category term="course-notes" /><summary type="html">Overview Threads are basically mini-processes within a process. However they share the same address space. Creating threads are much faster than creating processes, in some systems, this can be 10x to 100x faster. Think of threads as JS event loops, basically it. Classic Thread Model The classic thread model basically have all threads with their own stack and own PC. Everything else is shared. The software library will take care of scheduling. POSIX Thread Standard Some useful calls: pthread_create: New thread pthread_exit: Quite the calling thread pthread_join: Wait for a thread to exit pthread_yield: Give up CPU for another thread pthread_attr_init: Create a thread attribute structure pthread_attr_destroy: Remove a thread’s attribute structure User Space Thread Implementation If implemented in user space, then the library have to take care of scheduling and switching. However if hardware do support store/load registers, this operation can be done very quickly, which is much faster than trapping to kernel. And since everything is local, no context switch is needed, no kernel calls, it is very fast. Each process can also have its own scheduling algorithm. Drawbacks Thread cannot make blocking kernel calls, since that will halt all threads. Sometimes library will wrap the actual system call, but it is not really that nice to do. Another issue is page fault. Which will be discussed in memory management (basically blocking the process because it needs to read instructions from disk). In user space thread implementations, there is no clock interrupts. So a thread must give up the CPU before another thread can be run. Kernel Space Thread Implementation</summary></entry><entry><title type="html">CSCC69 Operating Systems - Processes</title><link href="https://jackzh.com/cscc69/2019/02/13/cscc69-processes.html" rel="alternate" type="text/html" title="CSCC69 Operating Systems - Processes" /><published>2019-02-13T08:54:00-06:00</published><updated>2019-02-13T08:54:00-06:00</updated><id>https://jackzh.com/cscc69/2019/02/13/cscc69-processes</id><content type="html" xml:base="https://jackzh.com/cscc69/2019/02/13/cscc69-processes.html">&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Processes allows computers to do multiple things at once.&lt;/p&gt;

&lt;p&gt;In multiprogramming system, CPU switches from process to process very quickly, make it seem that it is running them concurrently. This is usually called pseudoparallelism, in contrast to real-parallelism with multiprocessor.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In any given instant, only one process is running on one CPU.&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Context Switch&lt;/em&gt;: a context switch is the process of storing the state of a process or of a thread so that it can be restored and resumed later.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;drawbacks&quot;&gt;Drawbacks&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Programs cannot have assumption of timing. Say if you know 1 loop takes 0.01 millisec, you loop 1000 times to get 10 millisec. However, while in the loop, OS might already switched to another process.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;program-vs-process&quot;&gt;Program vs Process&lt;/h2&gt;

&lt;p&gt;An analogy:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Recepe: Program&lt;/li&gt;
  &lt;li&gt;Ingredients: Input Data&lt;/li&gt;
  &lt;li&gt;Process: Reading the recepe, getting ingredients and baking the cake.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now the guy’s son runs into room and says he has been stung by a bee. The guy records where he was in the recipe, gets first aid book and following that. After first aid has been done, he goes back to cooking. This is basically how OS switches processes.&lt;/p&gt;

&lt;p&gt;In real OS this is called scheduling. And if a programming is running twice, it is two processes.&lt;/p&gt;

&lt;h2 id=&quot;process-creation&quot;&gt;Process Creation&lt;/h2&gt;

&lt;p&gt;There are 4 principal events that cause processes to be created:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;System initialization&lt;/li&gt;
  &lt;li&gt;Execution of a process creation system call by a running process&lt;/li&gt;
  &lt;li&gt;A user request to create a new process&lt;/li&gt;
  &lt;li&gt;Initiation of a batch job&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are 2 main types: foreground and background (daemons).&lt;/p&gt;

&lt;p&gt;Technically, for all these cases, a new process is created by an existing process. In UNIX, only &lt;code class=&quot;highlighter-rouge&quot;&gt;fork&lt;/code&gt; can be used to create new processes. After fork, the child may change its memory image using &lt;code class=&quot;highlighter-rouge&quot;&gt;execve&lt;/code&gt;. Reason is so we can redirect IO before &lt;code class=&quot;highlighter-rouge&quot;&gt;execve&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Parent and child have different address space. However they may share text.&lt;/p&gt;

&lt;h2 id=&quot;process-termination&quot;&gt;Process Termination&lt;/h2&gt;

&lt;p&gt;There are 4 ways for a process to terminate.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Normal exit&lt;/li&gt;
  &lt;li&gt;Error exit&lt;/li&gt;
  &lt;li&gt;Fatal error&lt;/li&gt;
  &lt;li&gt;Killed by another process&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process-hierarchies&quot;&gt;Process Hierarchies&lt;/h2&gt;

&lt;p&gt;In UNIX, a process and all of its children form a process group. When a user sends a signal from the keyboard, all members are notified.&lt;/p&gt;

&lt;p&gt;In UNIX, all processes belong to a single tree, which &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; at the root. Processes cannot change parent (unless parent is killed by some reason).&lt;/p&gt;

&lt;h2 id=&quot;process-states&quot;&gt;Process States&lt;/h2&gt;

&lt;p&gt;There are 3 main states:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Running: Actually using the CPU&lt;/li&gt;
  &lt;li&gt;Ready: Can run, but temp stopped for another process to run&lt;/li&gt;
  &lt;li&gt;Blocked: Cannot run until some external event happens&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In UNIX, a process is automatically blocked if trying to read from an empty pipe.&lt;/p&gt;

&lt;h2 id=&quot;process-implementation&quot;&gt;Process Implementation&lt;/h2&gt;

&lt;p&gt;People use process table (PCB) to implement processes. Usually a table includes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;State&lt;/li&gt;
  &lt;li&gt;Memory allocation&lt;/li&gt;
  &lt;li&gt;Open files&lt;/li&gt;
  &lt;li&gt;Scheduling info&lt;/li&gt;
  &lt;li&gt;Registers&lt;/li&gt;
  &lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;interrupt-vector&quot;&gt;Interrupt Vector&lt;/h3&gt;

&lt;p&gt;Usually located at the bottom of the memory, when an interrupt happens, the hardware pushes process info onto stack, and jumps to interrupt vector. Then the interrupt procedure runs.&lt;/p&gt;

&lt;p&gt;All interrupts start by saving registers, this is usually done in assembly since C cannot access these information. Then the access is handed over to interrupt handler (stack is also reset).&lt;/p&gt;

&lt;p&gt;After the handler is done, the control is back to assembly to load the registers again.&lt;/p&gt;

&lt;p&gt;Overview of the basic procedures are listed below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hardware stacks basic program information&lt;/li&gt;
  &lt;li&gt;Hardware loads PC from IV.&lt;/li&gt;
  &lt;li&gt;Assembly saves registers&lt;/li&gt;
  &lt;li&gt;Assembly set up new stack.&lt;/li&gt;
  &lt;li&gt;Runs C interrupt service.&lt;/li&gt;
  &lt;li&gt;Scheduler decides which to run next.&lt;/li&gt;
  &lt;li&gt;C procedure returns to assembly code.&lt;/li&gt;
  &lt;li&gt;Assembly runs new process.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="cscc69" /><category term="cscc69" /><category term="course-notes" /><summary type="html">Overview Processes allows computers to do multiple things at once. In multiprogramming system, CPU switches from process to process very quickly, make it seem that it is running them concurrently. This is usually called pseudoparallelism, in contrast to real-parallelism with multiprocessor. In any given instant, only one process is running on one CPU. Context Switch: a context switch is the process of storing the state of a process or of a thread so that it can be restored and resumed later. Drawbacks Programs cannot have assumption of timing. Say if you know 1 loop takes 0.01 millisec, you loop 1000 times to get 10 millisec. However, while in the loop, OS might already switched to another process. Program vs Process An analogy: Recepe: Program Ingredients: Input Data Process: Reading the recepe, getting ingredients and baking the cake. Now the guy’s son runs into room and says he has been stung by a bee. The guy records where he was in the recipe, gets first aid book and following that. After first aid has been done, he goes back to cooking. This is basically how OS switches processes. In real OS this is called scheduling. And if a programming is running twice, it is two processes. Process Creation There are 4 principal events that cause processes to be created: System initialization Execution of a process creation system call by a running process A user request to create a new process Initiation of a batch job There are 2 main types: foreground and background (daemons). Technically, for all these cases, a new process is created by an existing process. In UNIX, only fork can be used to create new processes. After fork, the child may change its memory image using execve. Reason is so we can redirect IO before execve. Parent and child have different address space. However they may share text. Process Termination There are 4 ways for a process to terminate. Normal exit Error exit Fatal error Killed by another process Process Hierarchies In UNIX, a process and all of its children form a process group. When a user sends a signal from the keyboard, all members are notified. In UNIX, all processes belong to a single tree, which init at the root. Processes cannot change parent (unless parent is killed by some reason). Process States There are 3 main states: Running: Actually using the CPU Ready: Can run, but temp stopped for another process to run Blocked: Cannot run until some external event happens In UNIX, a process is automatically blocked if trying to read from an empty pipe. Process Implementation People use process table (PCB) to implement processes. Usually a table includes: State Memory allocation Open files Scheduling info Registers etc. Interrupt Vector Usually located at the bottom of the memory, when an interrupt happens, the hardware pushes process info onto stack, and jumps to interrupt vector. Then the interrupt procedure runs. All interrupts start by saving registers, this is usually done in assembly since C cannot access these information. Then the access is handed over to interrupt handler (stack is also reset). After the handler is done, the control is back to assembly to load the registers again. Overview of the basic procedures are listed below: Hardware stacks basic program information Hardware loads PC from IV. Assembly saves registers Assembly set up new stack. Runs C interrupt service. Scheduler decides which to run next. C procedure returns to assembly code. Assembly runs new process.</summary></entry></feed>